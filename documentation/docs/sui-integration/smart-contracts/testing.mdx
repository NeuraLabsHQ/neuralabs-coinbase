---
id: smart-contracts-testing
title: Smart Contracts Testing
sidebar_label: Testing
sidebar_position: 3
---

import { Card, CardHeader, CardTitle, CardDescription } from '@site/src/components/Card';

# <img src="/img/icons/code.svg" width="32" height="32" style={{ verticalAlign: 'middle', marginRight: '12px' }} />Smart Contracts Testing

Comprehensive testing strategies for NeuraLabs SUI Move contracts including unit tests, integration tests, and security validation.

## Testing Overview

The NeuraLabs smart contract testing suite covers multiple layers:

- **Unit Tests**: Test individual functions and modules
- **Integration Tests**: Test contract interactions and workflows
- **Security Tests**: Validate access control and security measures
- **Performance Tests**: Measure gas usage and execution time
- **End-to-End Tests**: Full workflow testing with frontend integration

## Unit Testing

### 1. Move Unit Tests

```move
// tests/nft_tests.move
#[test_only]
module neuranft::nft_tests {
    use neuranft::nft;
    use sui::test_scenario::{Self, Scenario};
    use sui::test_utils;
    
    #[test]
    fun test_nft_creation() {
        let scenario_val = test_scenario::begin(@0x1);
        let scenario = &mut scenario_val;
        
        test_scenario::next_tx(scenario, @0x1);
        {
            // Test NFT creation with valid parameters
            nft::create_nft(
                b"Test Model",
                b"A test AI model",
                6,
                test_scenario::ctx(scenario)
            );
        };
        
        test_scenario::next_tx(scenario, @0x1);
        {
            // Verify NFT was created correctly
            let nft_obj = test_scenario::take_from_sender<nft::NFT>(scenario);
            assert!(nft::get_access_level(&nft_obj) == 6, 0);
            test_scenario::return_to_sender(scenario, nft_obj);
        };
        
        test_scenario::end(scenario_val);
    }
    
    #[test]
    fun test_access_control() {
        let scenario_val = test_scenario::begin(@0x1);
        let scenario = &mut scenario_val;
        
        // Create NFT with owner
        test_scenario::next_tx(scenario, @0x1);
        {
            nft::create_nft(
                b"Test Model",
                b"Test description", 
                6,
                test_scenario::ctx(scenario)
            );
        };
        
        // Grant access to another user
        test_scenario::next_tx(scenario, @0x1);
        {
            let nft_obj = test_scenario::take_from_sender<nft::NFT>(scenario);
            nft::grant_access(
                &mut nft_obj,
                @0x2,
                4,
                test_scenario::ctx(scenario)
            );
            test_scenario::return_to_sender(scenario, nft_obj);
        };
        
        // Verify access was granted
        test_scenario::next_tx(scenario, @0x2);
        {
            let nft_obj = test_scenario::take_from_address<nft::NFT>(scenario, @0x1);
            assert!(nft::check_access(&nft_obj, @0x2) >= 4, 0);
            test_scenario::return_to_address(scenario, @0x1, nft_obj);
        };
        
        test_scenario::end(scenario_val);
    }
    
    #[test]
    #[expected_failure(abort_code = nft::EInsufficientAccess)]
    fun test_unauthorized_access() {
        let scenario_val = test_scenario::begin(@0x1);
        let scenario = &mut scenario_val;
        
        // Create NFT
        test_scenario::next_tx(scenario, @0x1);
        {
            nft::create_nft(b"Test", b"Test", 6, test_scenario::ctx(scenario));
        };
        
        // Try to grant access from unauthorized user (should fail)
        test_scenario::next_tx(scenario, @0x2);
        {
            let nft_obj = test_scenario::take_from_address<nft::NFT>(scenario, @0x1);
            nft::grant_access(&mut nft_obj, @0x3, 5, test_scenario::ctx(scenario));
            test_scenario::return_to_address(scenario, @0x1, nft_obj);
        };
        
        test_scenario::end(scenario_val);
    }
}
```

### 2. Running Unit Tests

```bash
# Run all unit tests
sui move test

# Run specific test module
sui move test --filter nft_tests

# Run with verbose output
sui move test -v

# Run with coverage
sui move test --coverage

# Run specific test function
sui move test --filter test_nft_creation
```

## Integration Testing

### 1. Python Integration Tests

```python
# test_integration.py
import asyncio
import pytest
from sui_python_sdk import SuiClient, Ed25519Keypair
from sui_python_sdk.types import TransactionBlock

class TestNeuraLabsContract:
    def setup_method(self):
        self.client = SuiClient("https://fullnode.testnet.sui.io:443")
        self.package_id = "YOUR_PACKAGE_ID"
        self.owner_keypair = Ed25519Keypair.from_seed(b"your_test_seed")
        self.user_keypair = Ed25519Keypair.from_seed(b"user_test_seed")
    
    async def test_nft_lifecycle(self):
        """Test complete NFT lifecycle: create, grant access, transfer"""
        
        # 1. Create NFT
        tx = TransactionBlock()
        tx.move_call(
            target=f"{self.package_id}::nft::create_nft",
            arguments=[
                tx.pure.string("Integration Test Model"),
                tx.pure.string("Test description"),
                tx.pure.u8(6),
            ],
        )
        
        result = await self.client.sign_and_execute_transaction_block({
            "signer": self.owner_keypair,
            "transactionBlock": tx,
            "options": {"showEffects": True, "showEvents": True},
        })
        
        assert result.is_success()
        nft_id = self.extract_created_object_id(result)
        
        # 2. Grant access to user
        tx = TransactionBlock()
        tx.move_call(
            target=f"{self.package_id}::access::grant_access",
            arguments=[
                tx.object(nft_id),
                tx.pure.address(self.user_keypair.public_key.to_sui_address()),
                tx.pure.u8(4),
            ],
        )
        
        result = await self.client.sign_and_execute_transaction_block({
            "signer": self.owner_keypair,
            "transactionBlock": tx,
            "options": {"showEffects": True},
        })
        
        assert result.is_success()
        
        # 3. Verify access
        access_level = await self.check_user_access(nft_id, self.user_keypair.public_key.to_sui_address())
        assert access_level >= 4
    
    async def test_seal_integration(self):
        """Test Seal approve function integration"""
        
        # Create NFT first
        nft_id = await self.create_test_nft()
        
        # Test seal_approve function
        tx = TransactionBlock()
        tx.move_call(
            target=f"{self.package_id}::nft::seal_approve",
            arguments=[
                tx.pure.vector("u8", [1, 2, 3, 4]),  # test ID
                tx.object(nft_id),
            ],
        )
        
        result = await self.client.sign_and_execute_transaction_block({
            "signer": self.owner_keypair,
            "transactionBlock": tx,
            "options": {"showEffects": True, "showEvents": True},
        })
        
        assert result.is_success()
        
        # Verify seal approval event was emitted
        events = result.events
        seal_events = [e for e in events if "SealApproval" in str(e)]
        assert len(seal_events) > 0
    
    async def test_access_control_hierarchy(self):
        """Test access control level hierarchy"""
        
        nft_id = await self.create_test_nft()
        
        # Test different access levels
        access_levels = [1, 2, 3, 4, 5, 6]
        
        for level in access_levels:
            # Grant access
            await self.grant_access(nft_id, self.user_keypair.public_key.to_sui_address(), level)
            
            # Verify access
            user_level = await self.check_user_access(nft_id, self.user_keypair.public_key.to_sui_address())
            assert user_level == level
            
            # Test that user can access lower levels
            for test_level in range(1, level + 1):
                assert await self.can_access_level(nft_id, self.user_keypair.public_key.to_sui_address(), test_level)
    
    # Helper methods
    async def create_test_nft(self):
        """Helper to create test NFT"""
        # Implementation here
        pass
    
    async def grant_access(self, nft_id, user_address, level):
        """Helper to grant access"""
        # Implementation here
        pass
    
    async def check_user_access(self, nft_id, user_address):
        """Helper to check user access level"""
        # Implementation here
        pass

# Run tests
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

### 2. Running Integration Tests

```bash
# Install test dependencies
pip install pytest pytest-asyncio sui-python-sdk

# Run integration tests
python -m pytest test_integration.py -v

# Run with coverage
python -m pytest test_integration.py --cov=contract_integration

# Run specific test
python -m pytest test_integration.py::TestNeuraLabsContract::test_nft_lifecycle -v
```

## Security Testing

### 1. Access Control Tests

```python
# test_security.py
import pytest
from sui_python_sdk import SuiClient
from sui_python_sdk.types import TransactionBlock

class TestSecurityValidation:
    
    async def test_unauthorized_access_prevention(self):
        """Test that unauthorized users cannot grant/revoke access"""
        
        # Create NFT as owner
        nft_id = await self.create_nft_as_owner()
        
        # Try to grant access as non-owner (should fail)
        with pytest.raises(Exception, match="EInsufficientAccess"):
            await self.grant_access_as_user(nft_id, "some_address", 4)
    
    async def test_access_level_constraints(self):
        """Test access level boundary conditions"""
        
        nft_id = await self.create_nft_as_owner()
        
        # Test invalid access levels
        invalid_levels = [0, 7, 255]
        for level in invalid_levels:
            with pytest.raises(Exception, match="EInvalidAccessLevel"):
                await self.grant_access_as_owner(nft_id, "user_address", level)
    
    async def test_seal_minimum_access_requirement(self):
        """Test that Seal functions require minimum access level 4"""
        
        nft_id = await self.create_nft_as_owner()
        
        # Grant level 3 access (below Seal requirement)
        await self.grant_access_as_owner(nft_id, self.user_address, 3)
        
        # Try to use seal_approve (should fail)
        with pytest.raises(Exception, match="EInsufficientAccess"):
            await self.call_seal_approve_as_user(nft_id)
        
        # Grant level 4 access (meets Seal requirement)
        await self.grant_access_as_owner(nft_id, self.user_address, 4)
        
        # Now seal_approve should work
        result = await self.call_seal_approve_as_user(nft_id)
        assert result.is_success()
    
    async def test_input_validation(self):
        """Test input validation and sanitization"""
        
        # Test with malformed inputs
        malformed_inputs = [
            ("", "Valid description", 6),  # Empty name
            ("Valid name", "", 6),         # Empty description
            ("Valid name", "Valid desc", 0), # Invalid access level
        ]
        
        for name, desc, level in malformed_inputs:
            with pytest.raises(Exception):
                await self.create_nft_with_params(name, desc, level)
```

### 2. Gas Analysis Tests

```python
# test_performance.py
class TestPerformanceMetrics:
    
    async def test_gas_usage_analysis(self):
        """Analyze gas usage for different operations"""
        
        gas_metrics = {}
        
        # Test NFT creation gas usage
        tx_result = await self.create_nft_with_gas_analysis()
        gas_metrics["nft_creation"] = tx_result.gas_used
        
        # Test access granting gas usage
        nft_id = await self.create_test_nft()
        tx_result = await self.grant_access_with_gas_analysis(nft_id)
        gas_metrics["access_grant"] = tx_result.gas_used
        
        # Test seal approval gas usage
        tx_result = await self.seal_approve_with_gas_analysis(nft_id)
        gas_metrics["seal_approve"] = tx_result.gas_used
        
        # Verify gas usage is within expected ranges
        assert gas_metrics["nft_creation"] < 10000000  # 0.01 SUI
        assert gas_metrics["access_grant"] < 5000000   # 0.005 SUI
        assert gas_metrics["seal_approve"] < 2000000   # 0.002 SUI
        
        print("Gas Usage Analysis:")
        for operation, gas_used in gas_metrics.items():
            print(f"  {operation}: {gas_used} gas units")
    
    async def test_batch_operations(self):
        """Test performance of batch operations"""
        
        nft_id = await self.create_test_nft()
        
        # Test batch access granting
        start_time = time.time()
        batch_size = 10
        
        for i in range(batch_size):
            user_address = self.generate_test_address(i)
            await self.grant_access(nft_id, user_address, 4)
        
        end_time = time.time()
        avg_time = (end_time - start_time) / batch_size
        
        assert avg_time < 2.0  # Each operation should take less than 2 seconds
        print(f"Average time per access grant: {avg_time:.3f} seconds")
```

## Automated Testing Pipeline

### 1. GitHub Actions Workflow

```yaml
# .github/workflows/contract-tests.yml
name: Smart Contract Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  move-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Sui CLI
      run: |
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
        source ~/.bashrc
        cargo install --locked --git https://github.com/MystenLabs/sui.git --branch testnet sui
    
    - name: Run Move unit tests
      run: |
        cd mov_contract/neuranft_contract
        sui move test
    
    - name: Run Move test with coverage
      run: |
        cd mov_contract/neuranft_contract
        sui move test --coverage
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./build/coverage/coverage.info

  integration-tests:
    runs-on: ubuntu-latest
    needs: move-tests
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-asyncio
    
    - name: Run integration tests
      run: |
        python -m pytest test_integration.py -v
    
    - name: Run security tests
      run: |
        python -m pytest test_security.py -v

  performance-tests:
    runs-on: ubuntu-latest
    needs: integration-tests
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Run performance benchmarks
      run: |
        python -m pytest test_performance.py -v --benchmark-only
```

### 2. Test Configuration

```bash
# Create test configuration
cat > test-config.json << EOF
{
  "networks": {
    "testnet": {
      "rpc_url": "https://fullnode.testnet.sui.io:443",
      "package_id": "$PACKAGE_ID",
      "gas_budget": 10000000
    }
  },
  "test_accounts": {
    "owner": "test_seed_1",
    "user1": "test_seed_2", 
    "user2": "test_seed_3"
  },
  "performance_limits": {
    "max_gas_per_operation": 10000000,
    "max_execution_time": 5.0
  }
}
EOF
```

## Test Results and Reporting

### 1. Coverage Reports

```bash
# Generate comprehensive coverage report
sui move test --coverage --coverage-format html

# View coverage in browser
open build/coverage/index.html
```

### 2. Performance Benchmarks

```bash
# Run performance benchmark suite
python scripts/benchmark.py --iterations 100 --report-format json

# Generate performance report
python scripts/generate_performance_report.py
```

## Continuous Monitoring

### 1. On-chain Test Monitoring

```python
# monitor_contracts.py
import asyncio
from sui_python_sdk import SuiClient

async def monitor_contract_health():
    """Monitor deployed contracts for health and performance"""
    
    client = SuiClient("https://fullnode.testnet.sui.io:443")
    package_id = "YOUR_PACKAGE_ID"
    
    # Check contract object still exists
    try:
        package_info = await client.get_object(package_id)
        assert package_info.status == "Exists"
        print("✅ Contract package healthy")
    except Exception as e:
        print(f"❌ Contract package error: {e}")
    
    # Monitor recent transactions
    events = await client.query_events({
        "MoveEventType": f"{package_id}::nft::NFTCreated"
    })
    
    print(f"📊 Recent NFT creations: {len(events.data)}")

if __name__ == "__main__":
    asyncio.run(monitor_contract_health())
```

## Next Steps

1. **[Integration Guide](./integration)** - Frontend and backend integration
2. **[Performance Optimization](./optimization)** - Gas and execution optimization
3. **[Seal Integration](../encryption/seal)** - Configure threshold encryption
4. **[Security Audit](./security-audit)** - Professional security assessment

## References

- [SUI Move Testing Framework](https://docs.sui.io/guides/developer/first-app/debug)
- [Move Unit Testing](https://move-language.github.io/move/unit-testing.html)
- [SUI TypeScript SDK Testing](https://sdk.mystenlabs.com/typescript/testing)