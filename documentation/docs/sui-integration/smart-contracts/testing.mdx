---
id: smart-contracts-testing
title: Smart Contracts Testing
sidebar_label: Testing
sidebar_position: 3
---

import { Card, CardHeader, CardTitle, CardDescription } from '@site/src/components/Card';
import { CollapsibleCodeBlock, InlineCodeCard } from '@site/src/components/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Smart Contracts Testing

Comprehensive testing guide for NeuraLabs SUI Move contracts including unit tests, integration tests, security validation, performance testing, and end-to-end workflows.

## Testing Overview

The NeuraLabs smart contract testing suite provides comprehensive coverage across multiple testing layers, ensuring robust validation of contract functionality, security, and performance.

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <Card>
    <CardHeader>
      <CardTitle>
        <span style={{ display: 'flex', alignItems: 'center' }}><img src="/img/icons/code.svg" width="20" height="20" style={{ marginRight: '8px' }} />Unit Testing</span>
      </CardTitle>
      <CardDescription>
        Move unit tests for individual functions and modules with comprehensive coverage
      </CardDescription>
    </CardHeader>
  </Card>

  <Card>
    <CardHeader>
      <CardTitle>
        <span style={{ display: 'flex', alignItems: 'center' }}><img src="/img/icons/network.svg" width="20" height="20" style={{ marginRight: '8px' }} />Integration Testing</span>
      </CardTitle>
      <CardDescription>
        Python-based integration tests for contract interactions and workflows
      </CardDescription>
    </CardHeader>
  </Card>

  <Card>
    <CardHeader>
      <CardTitle>
        <span style={{ display: 'flex', alignItems: 'center' }}><img src="/img/icons/security.svg" width="20" height="20" style={{ marginRight: '8px' }} />Security Testing</span>
      </CardTitle>
      <CardDescription>
        Access control validation and security vulnerability assessment
      </CardDescription>
    </CardHeader>
  </Card>

  <Card>
    <CardHeader>
      <CardTitle>
        <span style={{ display: 'flex', alignItems: 'center' }}><img src="/img/icons/hpc.svg" width="20" height="20" style={{ marginRight: '8px' }} />Performance Testing</span>
      </CardTitle>
      <CardDescription>
        Gas usage analysis, throughput measurement, and optimization validation
      </CardDescription>
    </CardHeader>
  </Card>

  <Card>
    <CardHeader>
      <CardTitle>
        <span style={{ display: 'flex', alignItems: 'center' }}><img src="/img/icons/frontend.svg" width="20" height="20" style={{ marginRight: '8px' }} />End-to-End Testing</span>
      </CardTitle>
      <CardDescription>
        Complete workflow testing with frontend integration and Seal encryption
      </CardDescription>
    </CardHeader>
  </Card>

  <Card>
    <CardHeader>
      <CardTitle>
        <span style={{ display: 'flex', alignItems: 'center' }}><img src="/img/icons/terminal.svg" width="20" height="20" style={{ marginRight: '8px' }} />Continuous Integration</span>
      </CardTitle>
      <CardDescription>
        Automated testing pipeline with GitHub Actions and monitoring
      </CardDescription>
    </CardHeader>
  </Card>
</div>

## Environment Setup

### Prerequisites

Before running the comprehensive test suite, ensure your testing environment is properly configured.

<Tabs>
  <TabItem value="conda" label="Conda Environment" default>
    ```bash
    # Create and activate conda environment
    conda create -n neuralabs-exec python=3.12
    conda activate neuralabs-exec
    
    # Install Python dependencies
    cd scripts
    pip install -r requirements.txt
    ```
  </TabItem>
  <TabItem value="node" label="Node.js Dependencies">
    ```bash
    # Install Node.js dependencies for Seal tests
    cd scripts
    npm install
    
    # Install additional testing packages
    npm install --save-dev @mysten/seal @mysten/sui.js
    ```
  </TabItem>
</Tabs>

### Test Configuration

<InlineCodeCard
  title="Test Configuration Setup"
  description="Configure test environment with proper network and account settings"
  language="bash"
  code={`# Copy and update test configuration
cp test-config.json test-config.local.json

# Set environment variables
export PACKAGE_ID=0x926de4be791b165822a8a213540c0606bb0d52450e5f8b6531097d9cd2c4dc64
export COLLECTION_ID=0x... # Your collection ID

# Example test-config.local.json
{
  "networks": {
    "testnet": {
      "rpc_url": "https://fullnode.testnet.sui.io:443",
      "package_id": "$PACKAGE_ID",
      "gas_budget": 10000000
    }
  },
  "test_accounts": {
    "owner": "test_seed_1",
    "user1": "test_seed_2",
    "user2": "test_seed_3"
  },
  "performance_limits": {
    "max_gas_per_operation": 10000000,
    "max_execution_time": 5.0
  }
}`}
/>

## Unit Testing

### 1. Move Unit Tests

The Move unit tests validate individual contract functions and ensure proper behavior under various conditions.

<CollapsibleCodeBlock
  title="Complete Move Unit Test Suite"
  description="Comprehensive unit tests for NFT creation, access control, and Seal integration"
  language="move"
  defaultCollapsed={true}
>
{`// tests/nft_tests.move
#[test_only]
module neuranft::nft_tests {
    use neuranft::nft;
    use neuranft::access;
    use sui::test_scenario::{Self, Scenario};
    use sui::test_utils;
    use sui::clock::{Self, Clock};
    
    #[test]
    fun test_nft_creation() {
        let scenario_val = test_scenario::begin(@0x1);
        let scenario = &mut scenario_val;
        
        test_scenario::next_tx(scenario, @0x1);
        {
            // Create collection first
            nft::create_collection(test_scenario::ctx(scenario));
        };
        
        test_scenario::next_tx(scenario, @0x1);
        {
            let collection = test_scenario::take_from_sender<nft::Collection>(scenario);
            let clock = clock::create_for_testing(test_scenario::ctx(scenario));
            
            // Test NFT creation with valid parameters
            nft::create_nft(
                &mut collection,
                b"Test AI Model",
                b"A comprehensive test AI model for validation",
                6, // Maximum access level
                &clock,
                test_scenario::ctx(scenario)
            );
            
            test_scenario::return_to_sender(scenario, collection);
            clock::destroy_for_testing(clock);
        };
        
        test_scenario::next_tx(scenario, @0x1);
        {
            // Verify NFT was created correctly
            let nft_obj = test_scenario::take_from_sender<nft::NFT>(scenario);
            assert!(nft::get_access_level(&nft_obj) == 6, 0);
            assert!(nft::get_name(&nft_obj) == b"Test AI Model", 1);
            test_scenario::return_to_sender(scenario, nft_obj);
        };
        
        test_scenario::end(scenario_val);
    }
    
    #[test]
    fun test_access_control_hierarchy() {
        let scenario_val = test_scenario::begin(@0x1);
        let scenario = &mut scenario_val;
        
        // Create NFT with owner
        test_scenario::next_tx(scenario, @0x1);
        {
            nft::create_collection(test_scenario::ctx(scenario));
        };
        
        test_scenario::next_tx(scenario, @0x1);
        {
            let collection = test_scenario::take_from_sender<nft::Collection>(scenario);
            let clock = clock::create_for_testing(test_scenario::ctx(scenario));
            
            nft::create_nft(
                &mut collection,
                b"Access Test Model",
                b"Testing access control hierarchy",
                6,
                &clock,
                test_scenario::ctx(scenario)
            );
            
            test_scenario::return_to_sender(scenario, collection);
            clock::destroy_for_testing(clock);
        };
        
        // Test access level granting
        test_scenario::next_tx(scenario, @0x1);
        {
            let nft_obj = test_scenario::take_from_sender<nft::NFT>(scenario);
            let clock = clock::create_for_testing(test_scenario::ctx(scenario));
            
            // Grant level 4 access (minimum for Seal decryption)
            access::grant_access(
                &mut nft_obj,
                @0x2,
                4,
                &clock,
                test_scenario::ctx(scenario)
            );
            
            test_scenario::return_to_sender(scenario, nft_obj);
            clock::destroy_for_testing(clock);
        };
        
        // Verify access levels work correctly
        test_scenario::next_tx(scenario, @0x2);
        {
            let nft_obj = test_scenario::take_from_address<nft::NFT>(scenario, @0x1);
            
            // User should have level 4 access
            assert!(access::check_access(&nft_obj, @0x2) == 4, 0);
            
            // User should be able to access levels 1-4
            assert!(access::can_access_level(&nft_obj, @0x2, 1), 1);
            assert!(access::can_access_level(&nft_obj, @0x2, 2), 2);
            assert!(access::can_access_level(&nft_obj, @0x2, 3), 3);
            assert!(access::can_access_level(&nft_obj, @0x2, 4), 4);
            
            // User should NOT be able to access levels 5-6
            assert!(!access::can_access_level(&nft_obj, @0x2, 5), 5);
            assert!(!access::can_access_level(&nft_obj, @0x2, 6), 6);
            
            test_scenario::return_to_address(scenario, @0x1, nft_obj);
        };
        
        test_scenario::end(scenario_val);
    }
    
    #[test]
    fun test_seal_approve_function() {
        let scenario_val = test_scenario::begin(@0x1);
        let scenario = &mut scenario_val;
        
        // Setup NFT
        test_scenario::next_tx(scenario, @0x1);
        {
            nft::create_collection(test_scenario::ctx(scenario));
        };
        
        test_scenario::next_tx(scenario, @0x1);
        {
            let collection = test_scenario::take_from_sender<nft::Collection>(scenario);
            let clock = clock::create_for_testing(test_scenario::ctx(scenario));
            
            nft::create_nft(
                &mut collection,
                b"Seal Test Model",
                b"Testing Seal integration",
                6,
                &clock,
                test_scenario::ctx(scenario)
            );
            
            test_scenario::return_to_sender(scenario, collection);
            clock::destroy_for_testing(clock);
        };
        
        // Grant access to test user
        test_scenario::next_tx(scenario, @0x1);
        {
            let nft_obj = test_scenario::take_from_sender<nft::NFT>(scenario);
            let clock = clock::create_for_testing(test_scenario::ctx(scenario));
            
            access::grant_access(&mut nft_obj, @0x2, 4, &clock, test_scenario::ctx(scenario));
            
            test_scenario::return_to_sender(scenario, nft_obj);
            clock::destroy_for_testing(clock);
        };
        
        // Test seal_approve function with valid access
        test_scenario::next_tx(scenario, @0x2);
        {
            let collection = test_scenario::take_from_address<nft::Collection>(scenario, @0x1);
            
            // This should succeed - user has level 4 access
            nft::seal_approve(
                vector[1, 2, 3, 4], // test identity bytes
                &collection,
                test_scenario::ctx(scenario)
            );
            
            test_scenario::return_to_address(scenario, @0x1, collection);
        };
        
        test_scenario::end(scenario_val);
    }
    
    #[test]
    #[expected_failure(abort_code = access::EInsufficientAccess)]
    fun test_unauthorized_access_failure() {
        let scenario_val = test_scenario::begin(@0x1);
        let scenario = &mut scenario_val;
        
        // Create NFT
        test_scenario::next_tx(scenario, @0x1);
        {
            nft::create_collection(test_scenario::ctx(scenario));
        };
        
        test_scenario::next_tx(scenario, @0x1);
        {
            let collection = test_scenario::take_from_sender<nft::Collection>(scenario);
            let clock = clock::create_for_testing(test_scenario::ctx(scenario));
            
            nft::create_nft(
                &mut collection,
                b"Unauthorized Test",
                b"Testing unauthorized access prevention",
                6,
                &clock,
                test_scenario::ctx(scenario)
            );
            
            test_scenario::return_to_sender(scenario, collection);
            clock::destroy_for_testing(clock);
        };
        
        // Try to grant access from unauthorized user (should fail)
        test_scenario::next_tx(scenario, @0x2);
        {
            let nft_obj = test_scenario::take_from_address<nft::NFT>(scenario, @0x1);
            let clock = clock::create_for_testing(test_scenario::ctx(scenario));
            
            // This should fail - @0x2 doesn't own the NFT
            access::grant_access(
                &mut nft_obj,
                @0x3,
                5,
                &clock,
                test_scenario::ctx(scenario)
            );
            
            test_scenario::return_to_address(scenario, @0x1, nft_obj);
            clock::destroy_for_testing(clock);
        };
        
        test_scenario::end(scenario_val);
    }
    
    #[test]
    #[expected_failure(abort_code = nft::EInsufficientAccessForSeal)]
    fun test_seal_access_requirement() {
        let scenario_val = test_scenario::begin(@0x1);
        let scenario = &mut scenario_val;
        
        // Setup NFT and grant insufficient access
        test_scenario::next_tx(scenario, @0x1);
        {
            nft::create_collection(test_scenario::ctx(scenario));
        };
        
        test_scenario::next_tx(scenario, @0x1);
        {
            let collection = test_scenario::take_from_sender<nft::Collection>(scenario);
            let clock = clock::create_for_testing(test_scenario::ctx(scenario));
            
            nft::create_nft(
                &mut collection,
                b"Seal Access Test",
                b"Testing Seal access requirements",
                6,
                &clock,
                test_scenario::ctx(scenario)
            );
            
            test_scenario::return_to_sender(scenario, collection);
            clock::destroy_for_testing(clock);
        };
        
        // Grant level 3 access (below Seal minimum)
        test_scenario::next_tx(scenario, @0x1);
        {
            let nft_obj = test_scenario::take_from_sender<nft::NFT>(scenario);
            let clock = clock::create_for_testing(test_scenario::ctx(scenario));
            
            access::grant_access(&mut nft_obj, @0x2, 3, &clock, test_scenario::ctx(scenario));
            
            test_scenario::return_to_sender(scenario, nft_obj);
            clock::destroy_for_testing(clock);
        };
        
        // Try to use seal_approve with insufficient access (should fail)
        test_scenario::next_tx(scenario, @0x2);
        {
            let collection = test_scenario::take_from_address<nft::Collection>(scenario, @0x1);
            
            // This should fail - user only has level 3 access, needs level 4+
            nft::seal_approve(
                vector[1, 2, 3, 4],
                &collection,
                test_scenario::ctx(scenario)
            );
            
            test_scenario::return_to_address(scenario, @0x1, collection);
        };
        
        test_scenario::end(scenario_val);
    }
}`}
</CollapsibleCodeBlock>
        
### 2. Running Unit Tests

<Tabs>
  <TabItem value="basic" label="Basic Testing" default>
    ```bash
    # Navigate to contract directory
    cd mov_contract/neuranft_contract
    
    # Run all unit tests
    sui move test
    
    # Run with verbose output
    sui move test -v
    ```
  </TabItem>
  <TabItem value="advanced" label="Advanced Options">
    ```bash
    # Run specific test module
    sui move test --filter nft_tests
    
    # Run specific test function
    sui move test --filter test_nft_creation
    
    # Run with coverage analysis
    sui move test --coverage
    
    # Generate HTML coverage report
    sui move test --coverage --coverage-format html
    ```
  </TabItem>
</Tabs>


## Integration Testing

### 1. Python Integration Tests

```python
# test_integration.py
import asyncio
import pytest
from sui_python_sdk import SuiClient, Ed25519Keypair
from sui_python_sdk.types import TransactionBlock

class TestNeuraLabsContract:
    def setup_method(self):
        self.client = SuiClient("https://fullnode.testnet.sui.io:443")
        self.package_id = "YOUR_PACKAGE_ID"
        self.owner_keypair = Ed25519Keypair.from_seed(b"your_test_seed")
        self.user_keypair = Ed25519Keypair.from_seed(b"user_test_seed")
    
    async def test_nft_lifecycle(self):
        """Test complete NFT lifecycle: create, grant access, transfer"""
        
        # 1. Create NFT
        tx = TransactionBlock()
        tx.move_call(
            target=f"{self.package_id}::nft::create_nft",
            arguments=[
                tx.pure.string("Integration Test Model"),
                tx.pure.string("Test description"),
                tx.pure.u8(6),
            ],
        )
        
        result = await self.client.sign_and_execute_transaction_block({
            "signer": self.owner_keypair,
            "transactionBlock": tx,
            "options": {"showEffects": True, "showEvents": True},
        })
        
        assert result.is_success()
        nft_id = self.extract_created_object_id(result)
        
        # 2. Grant access to user
        tx = TransactionBlock()
        tx.move_call(
            target=f"{self.package_id}::access::grant_access",
            arguments=[
                tx.object(nft_id),
                tx.pure.address(self.user_keypair.public_key.to_sui_address()),
                tx.pure.u8(4),
            ],
        )
        
        result = await self.client.sign_and_execute_transaction_block({
            "signer": self.owner_keypair,
            "transactionBlock": tx,
            "options": {"showEffects": True},
        })
        
        assert result.is_success()
        
        # 3. Verify access
        access_level = await self.check_user_access(nft_id, self.user_keypair.public_key.to_sui_address())
        assert access_level >= 4
    
    async def test_seal_integration(self):
        """Test Seal approve function integration"""
        
        # Create NFT first
        nft_id = await self.create_test_nft()
        
        # Test seal_approve function
        tx = TransactionBlock()
        tx.move_call(
            target=f"{self.package_id}::nft::seal_approve",
            arguments=[
                tx.pure.vector("u8", [1, 2, 3, 4]),  # test ID
                tx.object(nft_id),
            ],
        )
        
        result = await self.client.sign_and_execute_transaction_block({
            "signer": self.owner_keypair,
            "transactionBlock": tx,
            "options": {"showEffects": True, "showEvents": True},
        })
        
        assert result.is_success()
        
        # Verify seal approval event was emitted
        events = result.events
        seal_events = [e for e in events if "SealApproval" in str(e)]
        assert len(seal_events) > 0
    
    async def test_access_control_hierarchy(self):
        """Test access control level hierarchy"""
        
        nft_id = await self.create_test_nft()
        
        # Test different access levels
        access_levels = [1, 2, 3, 4, 5, 6]
        
        for level in access_levels:
            # Grant access
            await self.grant_access(nft_id, self.user_keypair.public_key.to_sui_address(), level)
            
            # Verify access
            user_level = await self.check_user_access(nft_id, self.user_keypair.public_key.to_sui_address())
            assert user_level == level
            
            # Test that user can access lower levels
            for test_level in range(1, level + 1):
                assert await self.can_access_level(nft_id, self.user_keypair.public_key.to_sui_address(), test_level)
    
    # Helper methods
    async def create_test_nft(self):
        """Helper to create test NFT"""
        # Implementation here
        pass
    
    async def grant_access(self, nft_id, user_address, level):
        """Helper to grant access"""
        # Implementation here
        pass
    
    async def check_user_access(self, nft_id, user_address):
        """Helper to check user access level"""
        # Implementation here
        pass

# Run tests
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

### 2. Running Integration Tests

```bash
# Install test dependencies
pip install pytest pytest-asyncio sui-python-sdk

# Run integration tests
python -m pytest test_integration.py -v

# Run with coverage
python -m pytest test_integration.py --cov=contract_integration

# Run specific test
python -m pytest test_integration.py::TestNeuraLabsContract::test_nft_lifecycle -v
```

## Security Testing

### 1. Access Control Tests

```python
# test_security.py
import pytest
from sui_python_sdk import SuiClient
from sui_python_sdk.types import TransactionBlock

class TestSecurityValidation:
    
    async def test_unauthorized_access_prevention(self):
        """Test that unauthorized users cannot grant/revoke access"""
        
        # Create NFT as owner
        nft_id = await self.create_nft_as_owner()
        
        # Try to grant access as non-owner (should fail)
        with pytest.raises(Exception, match="EInsufficientAccess"):
            await self.grant_access_as_user(nft_id, "some_address", 4)
    
    async def test_access_level_constraints(self):
        """Test access level boundary conditions"""
        
        nft_id = await self.create_nft_as_owner()
        
        # Test invalid access levels
        invalid_levels = [0, 7, 255]
        for level in invalid_levels:
            with pytest.raises(Exception, match="EInvalidAccessLevel"):
                await self.grant_access_as_owner(nft_id, "user_address", level)
    
    async def test_seal_minimum_access_requirement(self):
        """Test that Seal functions require minimum access level 4"""
        
        nft_id = await self.create_nft_as_owner()
        
        # Grant level 3 access (below Seal requirement)
        await self.grant_access_as_owner(nft_id, self.user_address, 3)
        
        # Try to use seal_approve (should fail)
        with pytest.raises(Exception, match="EInsufficientAccess"):
            await self.call_seal_approve_as_user(nft_id)
        
        # Grant level 4 access (meets Seal requirement)
        await self.grant_access_as_owner(nft_id, self.user_address, 4)
        
        # Now seal_approve should work
        result = await self.call_seal_approve_as_user(nft_id)
        assert result.is_success()
    
    async def test_input_validation(self):
        """Test input validation and sanitization"""
        
        # Test with malformed inputs
        malformed_inputs = [
            ("", "Valid description", 6),  # Empty name
            ("Valid name", "", 6),         # Empty description
            ("Valid name", "Valid desc", 0), # Invalid access level
        ]
        
        for name, desc, level in malformed_inputs:
            with pytest.raises(Exception):
                await self.create_nft_with_params(name, desc, level)
```

### 2. Gas Analysis Tests

```python
# test_performance.py
class TestPerformanceMetrics:
    
    async def test_gas_usage_analysis(self):
        """Analyze gas usage for different operations"""
        
        gas_metrics = {}
        
        # Test NFT creation gas usage
        tx_result = await self.create_nft_with_gas_analysis()
        gas_metrics["nft_creation"] = tx_result.gas_used
        
        # Test access granting gas usage
        nft_id = await self.create_test_nft()
        tx_result = await self.grant_access_with_gas_analysis(nft_id)
        gas_metrics["access_grant"] = tx_result.gas_used
        
        # Test seal approval gas usage
        tx_result = await self.seal_approve_with_gas_analysis(nft_id)
        gas_metrics["seal_approve"] = tx_result.gas_used
        
        # Verify gas usage is within expected ranges
        assert gas_metrics["nft_creation"] < 10000000  # 0.01 SUI
        assert gas_metrics["access_grant"] < 5000000   # 0.005 SUI
        assert gas_metrics["seal_approve"] < 2000000   # 0.002 SUI
        
        print("Gas Usage Analysis:")
        for operation, gas_used in gas_metrics.items():
            print(f"  {operation}: {gas_used} gas units")
    
    async def test_batch_operations(self):
        """Test performance of batch operations"""
        
        nft_id = await self.create_test_nft()
        
        # Test batch access granting
        start_time = time.time()
        batch_size = 10
        
        for i in range(batch_size):
            user_address = self.generate_test_address(i)
            await self.grant_access(nft_id, user_address, 4)
        
        end_time = time.time()
        avg_time = (end_time - start_time) / batch_size
        
        assert avg_time < 2.0  # Each operation should take less than 2 seconds
        print(f"Average time per access grant: {avg_time:.3f} seconds")
```

## Automated Testing Pipeline

### 1. GitHub Actions Workflow

```yaml
# .github/workflows/contract-tests.yml
name: Smart Contract Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  move-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Sui CLI
      run: |
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
        source ~/.bashrc
        cargo install --locked --git https://github.com/MystenLabs/sui.git --branch testnet sui
    
    - name: Run Move unit tests
      run: |
        cd mov_contract/neuranft_contract
        sui move test
    
    - name: Run Move test with coverage
      run: |
        cd mov_contract/neuranft_contract
        sui move test --coverage
    
    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./build/coverage/coverage.info

  integration-tests:
    runs-on: ubuntu-latest
    needs: move-tests
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-asyncio
    
    - name: Run integration tests
      run: |
        python -m pytest test_integration.py -v
    
    - name: Run security tests
      run: |
        python -m pytest test_security.py -v

  performance-tests:
    runs-on: ubuntu-latest
    needs: integration-tests
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Run performance benchmarks
      run: |
        python -m pytest test_performance.py -v --benchmark-only
```

### 2. Test Configuration

```bash
# Create test configuration
cat > test-config.json << EOF
{
  "networks": {
    "testnet": {
      "rpc_url": "https://fullnode.testnet.sui.io:443",
      "package_id": "$PACKAGE_ID",
      "gas_budget": 10000000
    }
  },
  "test_accounts": {
    "owner": "test_seed_1",
    "user1": "test_seed_2", 
    "user2": "test_seed_3"
  },
  "performance_limits": {
    "max_gas_per_operation": 10000000,
    "max_execution_time": 5.0
  }
}
EOF
```

## Test Results and Reporting

### 1. Coverage Reports

```bash
# Generate comprehensive coverage report
sui move test --coverage --coverage-format html

# View coverage in browser
open build/coverage/index.html
```

### 2. Performance Benchmarks

```bash
# Run performance benchmark suite
python scripts/benchmark.py --iterations 100 --report-format json

# Generate performance report
python scripts/generate_performance_report.py
```

## Continuous Monitoring

### 1. On-chain Test Monitoring

```python
# monitor_contracts.py
import asyncio
from sui_python_sdk import SuiClient

async def monitor_contract_health():
    """Monitor deployed contracts for health and performance"""
    
    client = SuiClient("https://fullnode.testnet.sui.io:443")
    package_id = "YOUR_PACKAGE_ID"
    
    # Check contract object still exists
    try:
        package_info = await client.get_object(package_id)
        assert package_info.status == "Exists"
        print("✅ Contract package healthy")
    except Exception as e:
        print(f"❌ Contract package error: {e}")
    
    # Monitor recent transactions
    events = await client.query_events({
        "MoveEventType": f"{package_id}::nft::NFTCreated"
    })
    
    print(f"📊 Recent NFT creations: {len(events.data)}")

if __name__ == "__main__":
    asyncio.run(monitor_contract_health())
```

## Next Steps

1. **[Integration Guide](./integration)** - Frontend and backend integration
2. **[Performance Optimization](./optimization)** - Gas and execution optimization
3. **[Seal Integration](../encryption/seal)** - Configure threshold encryption
4. **[Security Audit](./security-audit)** - Professional security assessment

## References

- [SUI Move Testing Framework](https://docs.sui.io/guides/developer/first-app/debug)
- [Move Unit Testing](https://move-language.github.io/move/unit-testing.html)
- [SUI TypeScript SDK Testing](https://sdk.mystenlabs.com/typescript/testing)