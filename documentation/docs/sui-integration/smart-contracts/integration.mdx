---
id: smart-contracts-integration
title: Smart Contracts Integration
sidebar_label: Integration
sidebar_position: 4
---

import { Card, CardHeader, CardTitle, CardDescription } from '@site/src/components/Card';

# <img src="/img/icons/network.svg" width="32" height="32" style={{ verticalAlign: 'middle', marginRight: '12px' }} />Smart Contracts Integration

Complete integration guide for connecting NeuraLabs smart contracts with frontend applications and backend services.

## Integration Overview

The NeuraLabs smart contracts integrate with multiple system components:

- **Frontend React Application**: User interface for NFT management
- **Backend API Services**: Server-side contract interactions
- **HPC Execution Engine**: Workflow execution with access control
- **zkLogin Authentication**: Seamless user authentication
- **Seal Encryption**: Threshold encryption integration
- **Walrus Storage**: Decentralized data storage

## Frontend Integration

### 1. TypeScript SDK Setup

```typescript
// lib/contract.ts
import { SuiClient, getFullnodeUrl } from '@mysten/sui.js/client';
import { TransactionBlock } from '@mysten/sui.js/transactions';
import { Ed25519Keypair } from '@mysten/sui.js/keypairs/ed25519';

// Contract configuration
export const CONTRACT_CONFIG = {
  packageId: process.env.REACT_APP_PACKAGE_ID || '',
  network: process.env.REACT_APP_SUI_NETWORK || 'testnet',
  rpcUrl: getFullnodeUrl(process.env.REACT_APP_SUI_NETWORK || 'testnet'),
};

// Initialize SUI client
export const suiClient = new SuiClient({ 
  url: CONTRACT_CONFIG.rpcUrl 
});

// Access levels enum
export enum AccessLevel {
  USE_MODEL = 1,
  RESALE = 2,
  CREATE_REPLICA = 3,
  VIEW_DOWNLOAD = 4,
  EDIT_DATA = 5,
  ABSOLUTE_OWNERSHIP = 6,
}

// Contract function interfaces
export interface NFTCreationParams {
  name: string;
  description: string;
  accessLevel: AccessLevel;
}

export interface AccessGrantParams {
  nftId: string;
  userAddress: string;
  accessLevel: AccessLevel;
}
```

### 2. Contract Interaction Functions

```typescript
// lib/contractFunctions.ts
import { TransactionBlock } from '@mysten/sui.js/transactions';
import { suiClient, CONTRACT_CONFIG, AccessLevel } from './contract';

export class NeuraLabsContract {
  private packageId: string;

  constructor() {
    this.packageId = CONTRACT_CONFIG.packageId;
  }

  /**
   * Create a new NFT with specified access level
   */
  async createNFT(params: NFTCreationParams, signer: any) {
    const tx = new TransactionBlock();
    
    tx.moveCall({
      target: `${this.packageId}::nft::create_nft`,
      arguments: [
        tx.pure.string(params.name),
        tx.pure.string(params.description),
        tx.pure.u8(params.accessLevel),
      ],
    });

    const result = await suiClient.signAndExecuteTransactionBlock({
      signer,
      transactionBlock: tx,
      options: { 
        showEffects: true, 
        showEvents: true,
        showObjectChanges: true 
      },
    });

    if (result.effects?.status?.status !== 'success') {
      throw new Error(`NFT creation failed: ${result.effects?.status?.error}`);
    }

    // Extract created NFT object ID
    const createdObjects = result.objectChanges?.filter(
      change => change.type === 'created'
    );
    
    const nftObject = createdObjects?.find(
      obj => obj.objectType.includes('::nft::NFT')
    );

    return {
      success: true,
      transactionDigest: result.digest,
      nftId: nftObject?.objectId,
      gasUsed: result.effects?.gasUsed,
    };
  }

  /**
   * Grant access to a user for specific NFT
   */
  async grantAccess(params: AccessGrantParams, signer: any) {
    const tx = new TransactionBlock();
    
    tx.moveCall({
      target: `${this.packageId}::access::grant_access`,
      arguments: [
        tx.object(params.nftId),
        tx.pure.address(params.userAddress),
        tx.pure.u8(params.accessLevel),
      ],
    });

    const result = await suiClient.signAndExecuteTransactionBlock({
      signer,
      transactionBlock: tx,
      options: { showEffects: true, showEvents: true },
    });

    return {
      success: result.effects?.status?.status === 'success',
      transactionDigest: result.digest,
      gasUsed: result.effects?.gasUsed,
    };
  }

  /**
   * Check user access level for specific NFT
   */
  async checkUserAccess(nftId: string, userAddress: string): Promise<number> {
    try {
      const tx = new TransactionBlock();
      
      tx.moveCall({
        target: `${this.packageId}::access::get_user_access_level`,
        arguments: [
          tx.object(nftId),
          tx.pure.address(userAddress),
        ],
      });

      // Use dev inspect to read contract state
      const result = await suiClient.devInspectTransactionBlock({
        transactionBlock: tx,
        sender: userAddress,
      });

      if (result.results?.[0]?.returnValues) {
        const accessLevel = result.results[0].returnValues[0][0];
        return parseInt(accessLevel.toString());
      }

      return 0;
    } catch (error) {
      console.error('Access check failed:', error);
      return 0;
    }
  }

  /**
   * Seal approve function for threshold encryption
   */
  async sealApprove(nftId: string, dataId: Uint8Array, signer: any) {
    const tx = new TransactionBlock();
    
    tx.moveCall({
      target: `${this.packageId}::nft::seal_approve`,
      arguments: [
        tx.pure.vector('u8', Array.from(dataId)),
        tx.object(nftId),
      ],
    });

    const result = await suiClient.signAndExecuteTransactionBlock({
      signer,
      transactionBlock: tx,
      options: { showEffects: true, showEvents: true },
    });

    return {
      success: result.effects?.status?.status === 'success',
      transactionDigest: result.digest,
      events: result.events,
    };
  }

  /**
   * Get NFT metadata and details
   */
  async getNFTDetails(nftId: string) {
    try {
      const object = await suiClient.getObject({
        id: nftId,
        options: { showContent: true, showOwner: true },
      });

      if (object.data?.content?.dataType === 'moveObject') {
        const fields = object.data.content.fields as any;
        
        return {
          id: nftId,
          name: fields.name,
          description: fields.description,
          accessLevel: fields.access_level,
          owner: object.data.owner,
          version: object.data.version,
        };
      }

      throw new Error('Invalid NFT object');
    } catch (error) {
      console.error('Failed to get NFT details:', error);
      throw error;
    }
  }

  /**
   * List all NFTs owned by a user
   */
  async getUserNFTs(userAddress: string) {
    try {
      const objects = await suiClient.getOwnedObjects({
        owner: userAddress,
        filter: {
          StructType: `${this.packageId}::nft::NFT`,
        },
        options: { showContent: true },
      });

      return objects.data.map(obj => {
        if (obj.data?.content?.dataType === 'moveObject') {
          const fields = obj.data.content.fields as any;
          return {
            id: obj.data.objectId,
            name: fields.name,
            description: fields.description,
            accessLevel: fields.access_level,
          };
        }
        return null;
      }).filter(Boolean);
    } catch (error) {
      console.error('Failed to get user NFTs:', error);
      return [];
    }
  }
}

// Export singleton instance
export const neuraLabsContract = new NeuraLabsContract();
```

### 3. React Hooks for Contract Integration

```typescript
// hooks/useContract.ts
import { useState, useEffect } from 'react';
import { useWallet } from '@mysten/wallet-kit';
import { neuraLabsContract, AccessLevel, NFTCreationParams } from '../lib/contractFunctions';

export function useNeuraLabsContract() {
  const { currentWallet } = useWallet();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const createNFT = async (params: NFTCreationParams) => {
    if (!currentWallet) {
      throw new Error('Wallet not connected');
    }

    setIsLoading(true);
    setError(null);

    try {
      const result = await neuraLabsContract.createNFT(
        params,
        currentWallet.signer
      );
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  };

  const grantAccess = async (nftId: string, userAddress: string, accessLevel: AccessLevel) => {
    if (!currentWallet) {
      throw new Error('Wallet not connected');
    }

    setIsLoading(true);
    setError(null);

    try {
      const result = await neuraLabsContract.grantAccess(
        { nftId, userAddress, accessLevel },
        currentWallet.signer
      );
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  };

  const checkUserAccess = async (nftId: string, userAddress: string) => {
    try {
      return await neuraLabsContract.checkUserAccess(nftId, userAddress);
    } catch (err) {
      console.error('Access check failed:', err);
      return 0;
    }
  };

  const sealApprove = async (nftId: string, dataId: Uint8Array) => {
    if (!currentWallet) {
      throw new Error('Wallet not connected');
    }

    setIsLoading(true);
    setError(null);

    try {
      const result = await neuraLabsContract.sealApprove(
        nftId,
        dataId,
        currentWallet.signer
      );
      
      return result;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  };

  return {
    createNFT,
    grantAccess,
    checkUserAccess,
    sealApprove,
    isLoading,
    error,
    clearError: () => setError(null),
  };
}

// Hook for NFT data
export function useNFTData(nftId: string | null) {
  const [nftData, setNftData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!nftId) return;

    const fetchNFTData = async () => {
      setIsLoading(true);
      setError(null);

      try {
        const data = await neuraLabsContract.getNFTDetails(nftId);
        setNftData(data);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to fetch NFT data';
        setError(errorMessage);
      } finally {
        setIsLoading(false);
      }
    };

    fetchNFTData();
  }, [nftId]);

  return { nftData, isLoading, error };
}

// Hook for user's NFTs
export function useUserNFTs(userAddress: string | null) {
  const [nfts, setNfts] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!userAddress) return;

    const fetchUserNFTs = async () => {
      setIsLoading(true);
      setError(null);

      try {
        const userNfts = await neuraLabsContract.getUserNFTs(userAddress);
        setNfts(userNfts);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to fetch user NFTs';
        setError(errorMessage);
      } finally {
        setIsLoading(false);
      }
    };

    fetchUserNFTs();
  }, [userAddress]);

  const refetch = () => {
    if (userAddress) {
      fetchUserNFTs();
    }
  };

  return { nfts, isLoading, error, refetch };
}
```

### 4. React Components

```typescript
// components/NFTManager.tsx
import React, { useState } from 'react';
import { useWallet } from '@mysten/wallet-kit';
import { useNeuraLabsContract } from '../hooks/useContract';
import { AccessLevel } from '../lib/contractFunctions';

export const NFTManager: React.FC = () => {
  const { currentAccount } = useWallet();
  const { createNFT, grantAccess, isLoading, error } = useNeuraLabsContract();
  
  const [nftForm, setNftForm] = useState({
    name: '',
    description: '',
    accessLevel: AccessLevel.ABSOLUTE_OWNERSHIP,
  });

  const [accessForm, setAccessForm] = useState({
    nftId: '',
    userAddress: '',
    accessLevel: AccessLevel.VIEW_DOWNLOAD,
  });

  const handleCreateNFT = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!currentAccount) {
      alert('Please connect your wallet');
      return;
    }

    try {
      const result = await createNFT(nftForm);
      alert(`NFT created successfully! ID: ${result.nftId}`);
      
      // Reset form
      setNftForm({
        name: '',
        description: '',
        accessLevel: AccessLevel.ABSOLUTE_OWNERSHIP,
      });
    } catch (err) {
      console.error('NFT creation failed:', err);
    }
  };

  const handleGrantAccess = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      const result = await grantAccess(
        accessForm.nftId,
        accessForm.userAddress,
        accessForm.accessLevel
      );
      
      if (result.success) {
        alert('Access granted successfully!');
        setAccessForm({
          nftId: '',
          userAddress: '',
          accessLevel: AccessLevel.VIEW_DOWNLOAD,
        });
      }
    } catch (err) {
      console.error('Access grant failed:', err);
    }
  };

  return (
    <div className="space-y-8">
      {/* NFT Creation Form */}
      <div className="card">
        <h3>Create New NFT</h3>
        <form onSubmit={handleCreateNFT} className="space-y-4">
          <div>
            <label htmlFor="name">NFT Name</label>
            <input
              id="name"
              type="text"
              value={nftForm.name}
              onChange={(e) => setNftForm({ ...nftForm, name: e.target.value })}
              required
            />
          </div>
          
          <div>
            <label htmlFor="description">Description</label>
            <textarea
              id="description"
              value={nftForm.description}
              onChange={(e) => setNftForm({ ...nftForm, description: e.target.value })}
              required
            />
          </div>
          
          <div>
            <label htmlFor="accessLevel">Access Level</label>
            <select
              id="accessLevel"
              value={nftForm.accessLevel}
              onChange={(e) => setNftForm({ ...nftForm, accessLevel: Number(e.target.value) })}
            >
              {Object.entries(AccessLevel)
                .filter(([key]) => isNaN(Number(key)))
                .map(([key, value]) => (
                  <option key={key} value={value}>
                    Level {value}: {key.replace('_', ' ')}
                  </option>
                ))}
            </select>
          </div>
          
          <button 
            type="submit" 
            disabled={isLoading || !currentAccount}
            className="btn-primary"
          >
            {isLoading ? 'Creating...' : 'Create NFT'}
          </button>
        </form>
      </div>

      {/* Access Management Form */}
      <div className="card">
        <h3>Grant Access</h3>
        <form onSubmit={handleGrantAccess} className="space-y-4">
          <div>
            <label htmlFor="nftId">NFT ID</label>
            <input
              id="nftId"
              type="text"
              value={accessForm.nftId}
              onChange={(e) => setAccessForm({ ...accessForm, nftId: e.target.value })}
              required
            />
          </div>
          
          <div>
            <label htmlFor="userAddress">User Address</label>
            <input
              id="userAddress"
              type="text"
              value={accessForm.userAddress}
              onChange={(e) => setAccessForm({ ...accessForm, userAddress: e.target.value })}
              required
            />
          </div>
          
          <div>
            <label htmlFor="grantAccessLevel">Access Level</label>
            <select
              id="grantAccessLevel"
              value={accessForm.accessLevel}
              onChange={(e) => setAccessForm({ ...accessForm, accessLevel: Number(e.target.value) })}
            >
              {Object.entries(AccessLevel)
                .filter(([key]) => isNaN(Number(key)))
                .map(([key, value]) => (
                  <option key={key} value={value}>
                    Level {value}: {key.replace('_', ' ')}
                  </option>
                ))}
            </select>
          </div>
          
          <button 
            type="submit" 
            disabled={isLoading || !currentAccount}
            className="btn-primary"
          >
            {isLoading ? 'Granting...' : 'Grant Access'}
          </button>
        </form>
      </div>

      {/* Error Display */}
      {error && (
        <div className="error-message">
          Error: {error}
        </div>
      )}
    </div>
  );
};
```

## Backend Integration

### 1. Python Backend Integration

```python
# backend/contract_integration.py
import asyncio
import os
from typing import Dict, List, Optional
from sui_python_sdk import SuiClient, Ed25519Keypair
from sui_python_sdk.types import TransactionBlock

class NeuraLabsContractService:
    def __init__(self):
        self.client = SuiClient(os.getenv('SUI_RPC_URL', 'https://fullnode.testnet.sui.io:443'))
        self.package_id = os.getenv('PACKAGE_ID')
        self.admin_keypair = self._load_admin_keypair()
    
    def _load_admin_keypair(self) -> Ed25519Keypair:
        """Load admin keypair from environment or config"""
        private_key = os.getenv('ADMIN_PRIVATE_KEY')
        if private_key:
            return Ed25519Keypair.from_private_key(bytes.fromhex(private_key))
        raise ValueError("Admin private key not configured")
    
    async def create_nft_for_user(
        self, 
        name: str, 
        description: str, 
        access_level: int,
        owner_address: str
    ) -> Dict:
        """Create NFT and transfer to user"""
        
        tx = TransactionBlock()
        
        # Create NFT
        nft_obj = tx.move_call(
            target=f"{self.package_id}::nft::create_nft",
            arguments=[
                tx.pure.string(name),
                tx.pure.string(description),
                tx.pure.u8(access_level),
            ],
        )
        
        # Transfer to user
        tx.transfer_object(nft_obj, owner_address)
        
        result = await self.client.sign_and_execute_transaction_block({
            "signer": self.admin_keypair,
            "transactionBlock": tx,
            "options": {"showEffects": True, "showObjectChanges": True},
        })
        
        if result.effects.status.status != "success":
            raise Exception(f"NFT creation failed: {result.effects.status.error}")
        
        # Extract created NFT ID
        created_objects = [
            change for change in result.object_changes 
            if change.type == "created" and "::nft::NFT" in change.object_type
        ]
        
        nft_id = created_objects[0].object_id if created_objects else None
        
        return {
            "success": True,
            "nft_id": nft_id,
            "transaction_digest": result.digest,
            "gas_used": result.effects.gas_used.total_cost,
        }
    
    async def verify_user_access(
        self, 
        nft_id: str, 
        user_address: str, 
        required_level: int = 4
    ) -> bool:
        """Verify user has required access level"""
        
        try:
            tx = TransactionBlock()
            
            tx.move_call(
                target=f"{self.package_id}::access::get_user_access_level",
                arguments=[
                    tx.object(nft_id),
                    tx.pure.address(user_address),
                ],
            )
            
            result = await self.client.dev_inspect_transaction_block({
                "transactionBlock": tx,
                "sender": user_address,
            })
            
            if result.results and result.results[0].return_values:
                access_level = int.from_bytes(
                    result.results[0].return_values[0][0], 
                    byteorder='little'
                )
                return access_level >= required_level
            
            return False
        except Exception as e:
            print(f"Access verification failed: {e}")
            return False
    
    async def batch_grant_access(
        self, 
        access_grants: List[Dict[str, any]]
    ) -> Dict:
        """Grant access to multiple users in batch"""
        
        successful_grants = []
        failed_grants = []
        
        for grant in access_grants:
            try:
                tx = TransactionBlock()
                
                tx.move_call(
                    target=f"{self.package_id}::access::grant_access",
                    arguments=[
                        tx.object(grant["nft_id"]),
                        tx.pure.address(grant["user_address"]),
                        tx.pure.u8(grant["access_level"]),
                    ],
                )
                
                result = await self.client.sign_and_execute_transaction_block({
                    "signer": self.admin_keypair,
                    "transactionBlock": tx,
                    "options": {"showEffects": True},
                })
                
                if result.effects.status.status == "success":
                    successful_grants.append({
                        **grant,
                        "transaction_digest": result.digest,
                    })
                else:
                    failed_grants.append({
                        **grant,
                        "error": result.effects.status.error,
                    })
                    
            except Exception as e:
                failed_grants.append({
                    **grant,
                    "error": str(e),
                })
        
        return {
            "successful_grants": successful_grants,
            "failed_grants": failed_grants,
            "total_processed": len(access_grants),
        }
    
    async def get_nft_analytics(self, nft_id: str) -> Dict:
        """Get analytics data for NFT"""
        
        # Get NFT details
        nft_object = await self.client.get_object({
            "id": nft_id,
            "options": {"showContent": True, "showOwner": True},
        })
        
        # Get access events
        events = await self.client.query_events({
            "MoveEventType": f"{self.package_id}::access::AccessGranted"
        })
        
        # Filter events for this NFT
        nft_events = [
            event for event in events.data 
            if event.parsed_json and event.parsed_json.get("nft_id") == nft_id
        ]
        
        return {
            "nft_id": nft_id,
            "owner": nft_object.data.owner,
            "total_access_grants": len(nft_events),
            "recent_activity": nft_events[:10],  # Last 10 events
        }

# FastAPI integration
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

app = FastAPI()
contract_service = NeuraLabsContractService()

class NFTCreationRequest(BaseModel):
    name: str
    description: str
    access_level: int
    owner_address: str

class AccessVerificationRequest(BaseModel):
    nft_id: str
    user_address: str
    required_level: int = 4

@app.post("/api/nft/create")
async def create_nft(request: NFTCreationRequest):
    try:
        result = await contract_service.create_nft_for_user(
            name=request.name,
            description=request.description,
            access_level=request.access_level,
            owner_address=request.owner_address,
        )
        return result
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/api/access/verify")
async def verify_access(request: AccessVerificationRequest):
    try:
        has_access = await contract_service.verify_user_access(
            nft_id=request.nft_id,
            user_address=request.user_address,
            required_level=request.required_level,
        )
        return {"has_access": has_access}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.get("/api/nft/{nft_id}/analytics")
async def get_nft_analytics(nft_id: str):
    try:
        analytics = await contract_service.get_nft_analytics(nft_id)
        return analytics
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

### 2. Environment Configuration

```bash
# Backend .env configuration
SUI_NETWORK=testnet
SUI_RPC_URL=https://fullnode.testnet.sui.io:443
PACKAGE_ID=your_deployed_package_id
ADMIN_PRIVATE_KEY=your_admin_private_key_hex

# Database configuration
DATABASE_URL=postgresql://user:password@localhost/neuralabs
REDIS_URL=redis://localhost:6379

# API configuration
API_HOST=0.0.0.0
API_PORT=8000
DEBUG=true
```

## Event Monitoring and Analytics

### 1. Event Listener Service

```typescript
// services/eventMonitor.ts
import { SuiClient } from '@mysten/sui.js/client';
import { CONTRACT_CONFIG } from '../lib/contract';

export class ContractEventMonitor {
  private client: SuiClient;
  private packageId: string;
  private listeners: Map<string, Function[]> = new Map();

  constructor() {
    this.client = new SuiClient({ url: CONTRACT_CONFIG.rpcUrl });
    this.packageId = CONTRACT_CONFIG.packageId;
  }

  /**
   * Subscribe to contract events
   */
  async subscribeToEvents() {
    try {
      // Subscribe to NFT creation events
      await this.client.subscribeEvent({
        filter: {
          MoveEventType: `${this.packageId}::nft::NFTCreated`,
        },
        onMessage: (event) => {
          this.emitEvent('nft-created', event);
        },
      });

      // Subscribe to access granted events
      await this.client.subscribeEvent({
        filter: {
          MoveEventType: `${this.packageId}::access::AccessGranted`,
        },
        onMessage: (event) => {
          this.emitEvent('access-granted', event);
        },
      });

      console.log('✅ Event monitoring started');
    } catch (error) {
      console.error('❌ Failed to subscribe to events:', error);
    }
  }

  /**
   * Add event listener
   */
  addEventListener(eventType: string, callback: Function) {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType)!.push(callback);
  }

  /**
   * Emit event to listeners
   */
  private emitEvent(eventType: string, data: any) {
    const callbacks = this.listeners.get(eventType) || [];
    callbacks.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error(`Error in event callback for ${eventType}:`, error);
      }
    });
  }

  /**
   * Get historical events
   */
  async getHistoricalEvents(eventType: string, limit: number = 100) {
    try {
      const events = await this.client.queryEvents({
        query: {
          MoveEventType: `${this.packageId}::${eventType}`,
        },
        limit,
        order: 'descending',
      });

      return events.data;
    } catch (error) {
      console.error(`Failed to get historical events for ${eventType}:`, error);
      return [];
    }
  }
}

// Export singleton instance
export const eventMonitor = new ContractEventMonitor();
```

## Error Handling and Retry Logic

### 1. Transaction Retry Service

```typescript
// services/transactionRetry.ts
import { SuiClient } from '@mysten/sui.js/client';
import { TransactionBlock } from '@mysten/sui.js/transactions';

export class TransactionRetryService {
  private maxRetries = 3;
  private baseDelay = 1000; // 1 second

  async executeWithRetry(
    client: SuiClient,
    transactionBlock: TransactionBlock,
    signer: any,
    options: any = {}
  ) {
    let lastError: Error;

    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        const result = await client.signAndExecuteTransactionBlock({
          signer,
          transactionBlock,
          options: { showEffects: true, ...options },
        });

        if (result.effects?.status?.status === 'success') {
          return result;
        } else {
          throw new Error(result.effects?.status?.error || 'Transaction failed');
        }
      } catch (error) {
        lastError = error as Error;
        
        console.warn(`Transaction attempt ${attempt} failed:`, error);

        // Don't retry on certain errors
        if (this.isNonRetryableError(error)) {
          throw error;
        }

        // Wait before retrying
        if (attempt < this.maxRetries) {
          const delay = this.baseDelay * Math.pow(2, attempt - 1);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw new Error(`Transaction failed after ${this.maxRetries} attempts. Last error: ${lastError.message}`);
  }

  private isNonRetryableError(error: any): boolean {
    const errorMessage = error.message?.toLowerCase() || '';
    
    // Don't retry on these types of errors
    const nonRetryableErrors = [
      'insufficient balance',
      'invalid signature',
      'object not found',
      'access denied',
      'einsufficientaccess',
    ];

    return nonRetryableErrors.some(msg => errorMessage.includes(msg));
  }
}

export const transactionRetry = new TransactionRetryService();
```

## Performance Optimization

### 1. Transaction Batching

```typescript
// services/batchProcessor.ts
export class BatchTransactionProcessor {
  private batchSize = 10;
  private processingQueue: any[] = [];
  private isProcessing = false;

  async addToBatch(operation: any) {
    this.processingQueue.push(operation);
    
    if (!this.isProcessing) {
      this.processBatch();
    }
  }

  private async processBatch() {
    if (this.isProcessing || this.processingQueue.length === 0) {
      return;
    }

    this.isProcessing = true;

    try {
      while (this.processingQueue.length > 0) {
        const batch = this.processingQueue.splice(0, this.batchSize);
        await this.executeBatch(batch);
        
        // Small delay between batches
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    } finally {
      this.isProcessing = false;
    }
  }

  private async executeBatch(operations: any[]) {
    const promises = operations.map(op => this.executeOperation(op));
    await Promise.allSettled(promises);
  }

  private async executeOperation(operation: any) {
    // Execute individual operation
    try {
      return await operation.execute();
    } catch (error) {
      console.error('Batch operation failed:', error);
      throw error;
    }
  }
}
```

## Next Steps

1. **[Seal Integration](../encryption/seal)** - Configure threshold encryption
2. **[Walrus Integration](../storage/walrus)** - Set up decentralized storage
3. **[Performance Monitoring](./monitoring)** - Set up monitoring and alerts
4. **[Security Audit](./security)** - Professional security assessment

## References

- [SUI TypeScript SDK](https://sdk.mystenlabs.com/typescript)
- [SUI Python SDK](https://github.com/FrankC01/pysui)
- [Wallet Kit Integration](https://kit.mysten.dev/)
- [SUI Event Subscription](https://docs.sui.io/guides/developer/events)