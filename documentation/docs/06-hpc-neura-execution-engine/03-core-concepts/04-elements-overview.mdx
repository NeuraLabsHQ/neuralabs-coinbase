---
id: hpc-elements
title: Elements
sidebar_label: Elements
sidebar_position: 4
---

import { Card, CardHeader, CardTitle, CardDescription } from '@site/src/components/Card';
import { Callout } from '@site/src/components/Callout';
import { Features, Feature } from '@site/src/components/Features';
import { CollapsibleCodeBlock, InlineCodeCard } from '@site/src/components/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

# Elements

Elements are the fundamental templates that define reusable components in the HPC Neura Execution Engine. Created by L1 developers and stored in the `element_data` table, elements serve as blueprints from which L2 developers create nodes for their flows.

<Callout type="info">
This page provides a deep dive into element structure and properties. For an overview of element types and categories, see the [Element Reference](/docs/hpc-neura-execution-engine/element-reference/overview) section.
</Callout>

## Element Anatomy

Every element consists of multiple properties that define its behavior, constraints, and customization options. Understanding these properties is crucial for both L1 developers creating elements and L2 developers using them.

<Tabs>
  <TabItem value="table" label="Element Table" default>
    <Card>
      <CardHeader>
        <CardTitle>Element Components Reference</CardTitle>
        <CardDescription>Complete list of all element properties and their descriptions</CardDescription>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <table>
          <thead>
            <tr>
              <th>Property</th>
              <th>Type</th>
              <th>Description</th>
              <th>Defined By</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>type</code></td>
              <td>string</td>
              <td>Element category identifier (e.g., llm_text, selector, case, custom)</td>
              <td>L1 Developer</td>
            </tr>
            <tr>
              <td><code>element_id</code></td>
              <td>string</td>
              <td>Unique identifier for the node instance in a flow</td>
              <td>Auto-generated</td>
            </tr>
            <tr>
              <td><code>name</code></td>
              <td>string</td>
              <td>Human-readable name for the node instance</td>
              <td>L2 Developer</td>
            </tr>
            <tr>
              <td><code>node_description</code></td>
              <td>string</td>
              <td>Base description of what the element type does</td>
              <td>L1 Developer</td>
            </tr>
            <tr>
              <td><code>description</code></td>
              <td>string</td>
              <td>Custom description for the specific node instance</td>
              <td>L2 Developer</td>
            </tr>
            <tr>
              <td><code>input_schema</code></td>
              <td>object</td>
              <td>Defines expected input structure with types, requirements, and constraints</td>
              <td>L1 Developer</td>
            </tr>
            <tr>
              <td><code>output_schema</code></td>
              <td>object</td>
              <td>Defines the structure of data produced by the element</td>
              <td>L1 Developer</td>
            </tr>
            <tr>
              <td><code>parameter_schema_structure</code></td>
              <td>object</td>
              <td>Defines valid parameter configurations and their constraints</td>
              <td>L1 Developer</td>
            </tr>
            <tr>
              <td><code>parameters</code></td>
              <td>object</td>
              <td>Actual configuration values for the element</td>
              <td>L1/L2 Developer</td>
            </tr>
            <tr>
              <td><code>processing_message</code></td>
              <td>string</td>
              <td>Message displayed during node execution</td>
              <td>L1/L2 Developer</td>
            </tr>
            <tr>
              <td><code>tags</code></td>
              <td>array</td>
              <td>Organizational tags for categorization and search</td>
              <td>L1/L2 Developer</td>
            </tr>
            <tr>
              <td><code>layer</code></td>
              <td>string</td>
              <td>Logical grouping layer for visual organization</td>
              <td>L2 Developer</td>
            </tr>
            <tr>
              <td><code>code</code></td>
              <td>string</td>
              <td>Python code for custom logic (custom elements only)</td>
              <td>L1/L2 Developer</td>
            </tr>
            <tr>
              <td><code>flow_control</code></td>
              <td>object</td>
              <td>Branching logic configuration (case/flow_select elements only)</td>
              <td>L1/L2 Developer</td>
            </tr>
            <tr>
              <td><code>hyperparameters</code></td>
              <td>object</td>
              <td>Access control configuration for each property</td>
              <td>L1 Developer</td>
            </tr>
            <tr>
              <td><code>input</code></td>
              <td>object</td>
              <td>Runtime input values provided during execution</td>
              <td>L3 User/L4 Runtime</td>
            </tr>
            <tr>
              <td><code>output</code></td>
              <td>object</td>
              <td>Runtime output values produced after execution</td>
              <td>L4 Runtime</td>
            </tr>
          </tbody>
        </table>
        
        <Callout type="info" style={{ marginTop: '1.5rem' }}>
          <strong>Access Levels in Hyperparameters:</strong>
          <ul style={{ marginTop: '0.5rem', marginBottom: 0 }}>
            <li><code>fixed</code> - Cannot be modified by L2 developers</li>
            <li><code>edit</code> - Full control for L2 developers</li>
            <li><code>append</code> - L2 can add but not remove (e.g., tags)</li>
            <li><code>hidden</code> - Present but not visible to L2/L3 users</li>
          </ul>
        </Callout>
      </div>
    </Card>
  </TabItem>
  
  <TabItem value="structure" label="Element Structure">
    <Card>
      <CardHeader>
        <CardTitle>Complete Element Structure</CardTitle>
        <CardDescription>Generic template showing all possible properties and their format</CardDescription>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <CollapsibleCodeBlock
          title="Full Element Structure with Placeholders"
          description="All properties an element can have with generic placeholders"
          language="yaml"
          defaultCollapsed={false}
        >
{`# Element Template Structure
type: "<element_type>"  # e.g., llm_text, selector, case, custom
element_id: "<auto_generated_id>"  # Generated when L2 creates node
name: "<custom_name>"  # Set by L2 developer
node_description: "<base_description>"  # From L1, describes element functionality
description: "<custom_description>"  # Optional, set by L2

# Input Schema - Expected inputs
input_schema:
  input_field_1:
    type: <string|int|float|bool|json|list>
    required: <true|false>
    description: "<field description>"
    # Optional constraints for inputs
    default: <default_value>
    enum: ["option1", "option2", "option3"]
    min_length: <number>  # For strings
    max_length: <number>  # For strings
    minimum: <number>     # For numbers
    maximum: <number>     # For numbers
    pattern: "<regex>"    # For strings
    
  input_field_2:
    type: <data_type>
    required: <true|false>
    description: "<field description>"
    
  # Additional input fields...

# Output Schema - What element produces
output_schema:
  output_field_1:
    type: <data_type>
    required: <true|false>
    description: "<field description>"
    
  output_field_2:
    type: <data_type>
    required: <true|false>
    description: "<field description>"
    
  # Additional output fields...

# Parameter Schema Structure - Valid parameter configurations
parameter_schema_structure:
  param_1:
    type: <data_type>
    description: "<parameter description>"
    # Constraints for this parameter
    enum: ["value1", "value2", "value3"]
    min: <minimum_value>
    max: <maximum_value>
    pattern: "<validation_regex>"
    
  param_2:
    type: <data_type>
    description: "<parameter description>"
    # Different constraints based on type
    
  # Additional parameters...

# Parameters - Actual configuration values
parameters:
  param_1: <default_value>
  param_2: <default_value>
  param_3: <default_value>
  # Special parameters (commonly hidden)
  api_key: "\${ENVIRONMENT_VARIABLE}"
  endpoint: "<service_endpoint>"
  # Additional configuration...

# UI/UX Properties
processing_message: "<message shown during execution>"
tags: ["<tag1>", "<tag2>", "<tag3>", "<additional_tags>"]
layer: "<organizational_layer>"  # e.g., input, processing, output

# Special Properties (Element Type Specific)

# For custom elements only:
code: |
  # Python code for custom logic
  input_value = inputs.get('input_field_1')
  # Processing logic...
  output['output_field_1'] = result

# For flow control elements only (case, flow_select):
flow_control:
  # For case elements:
  cases:
    - case_id_1:
        condition:
          variable1: "<path.to.variable>"
          variable2: "<value or path>"
          operator: "<==|!=|>|<|>=|<=>"
        enable_connections: ["<node_id_1>", "<node_id_2>"]
        disable_connections: ["<node_id_3>", "<node_id_4>"]
    - case_id_2:
        condition:
          variable1: "<path.to.variable>"
          variable2: "<value>"
          operator: "<operator>"
        enable_connections: ["<node_ids>"]
        
  # For flow_select elements:
  flow_options:
    - id: "<flow_option_1>"
      name: "<Display Name>"
      condition: "<selection_criteria>"
    - id: "<flow_option_2>"
      name: "<Display Name>"
      condition: "<selection_criteria>"

# Hyperparameters - Access control for each property
hyperparameters:
  # Core properties
  type:
    access: "<fixed|edit|append|hidden>"
    comment: "<explanation of access level>"
    
  element_id:
    access: "<access_level>"
    comment: "<explanation>"
    
  name:
    access: "<access_level>"
    comment: "<explanation>"
    
  node_description:
    access: "<access_level>"
    comment: "<explanation>"
    
  description:
    access: "<access_level>"
    comment: "<explanation>"
    
  # Schema access control
  input_schema:
    access: "<access_level>"
    comment: "<explanation>"
    
  output_schema:
    access: "<access_level>"
    comment: "<explanation>"
    
  # Parameter-level access control
  parameters.param_1:
    access: "<access_level>"
    comment: "<explanation>"
    
  parameters.param_2:
    access: "<access_level>"
    comment: "<explanation>"
    
  parameters.api_key:
    access: "hidden"  # Commonly hidden
    comment: "Sensitive credential"
    
  # UI properties access
  processing_message:
    access: "<access_level>"
    comment: "<explanation>"
    
  tags:
    access: "<access_level>"  # Often "append"
    comment: "<explanation>"
    
  layer:
    access: "<access_level>"
    comment: "<explanation>"
    
  # Special properties access
  code:
    access: "<access_level>"  # If custom element
    comment: "<explanation>"
    
  flow_control:
    access: "<access_level>"  # If flow control element
    comment: "<explanation>"`}
        </CollapsibleCodeBlock>
      </div>
    </Card>
  </TabItem>
  
  <TabItem value="example" label="Real Example">
    <Card>
      <CardHeader>
        <CardTitle>LLM Text Element Example</CardTitle>
        <CardDescription>Complete configuration of an actual LLM text generation element</CardDescription>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <CollapsibleCodeBlock
          title="Real LLM Text Element Configuration"
          description="Fully configured element with actual values"
          language="yaml"
          defaultCollapsed={false}
        >
{`# LLM Text Generation Element
type: "llm_text"
element_id: "llm_text_customer_service_v1"
name: "Customer Service AI Assistant"
node_description: "AI text generation using large language models with streaming support"
description: "Specialized for customer service interactions with context awareness"

# Input Schema
input_schema:
  prompt:
    type: string
    required: true
    description: "The user query or prompt for AI generation"
    max_length: 4000
    
  context:
    type: list
    required: false
    description: "Previous conversation messages for context"
    default: []
    
  temperature:
    type: float
    required: false
    description: "Controls response creativity (0=deterministic, 1=creative)"
    default: 0.7
    minimum: 0.0
    maximum: 1.0
    
  system_prompt:
    type: string
    required: false
    description: "System-level instructions for the AI"
    default: "You are a helpful assistant."

# Output Schema
output_schema:
  llm_output:
    type: string
    required: true
    description: "The generated AI response text"
    
  tokens_used:
    type: int
    required: false
    description: "Number of tokens consumed in generation"
    
  model_used:
    type: string
    required: false
    description: "The model that was used for generation"
    
  generation_time_ms:
    type: int
    required: false
    description: "Time taken for generation in milliseconds"

# Parameter Schema Structure
parameter_schema_structure:
  model:
    type: string
    description: "AI model to use for generation"
    enum: ["llama-3.3-70b", "deepseek-r1", "claude-3-haiku", "claude-3-sonnet"]
    
  temperature:
    type: float
    description: "Default temperature for responses"
    min: 0.0
    max: 1.0
    
  max_tokens:
    type: int
    description: "Maximum tokens to generate"
    min: 1
    max: 8000
    
  stream:
    type: bool
    description: "Enable streaming responses"
    
  wrapper_prompt:
    type: string
    description: "Template to wrap user prompts"
    
  stop_sequences:
    type: list
    description: "Sequences that stop generation"

# Parameters
parameters:
  model: "llama-3.3-70b"
  temperature: 0.7
  max_tokens: 2000
  stream: true
  wrapper_prompt: |
    You are a professional customer service representative for TechCorp.
    Be helpful, polite, and concise.
    
    Customer Query: {prompt}
    
    Previous Context: {context}
    
    Response:
  stop_sequences: ["\\n\\nCustomer:", "\\n\\nHuman:"]
  api_endpoint: "\${AWS_BEDROCK_ENDPOINT}"
  api_key: "\${AWS_BEDROCK_KEY}"
  retry_attempts: 3
  timeout_seconds: 30

# UI/UX Properties
processing_message: "AI is crafting a thoughtful response..."
tags: ["ai", "llm", "text-generation", "customer-service", "streaming", "production-ready"]
layer: "ai-processing"

# Hyperparameters - Access Control
hyperparameters:
  # Core properties - mostly fixed
  type:
    access: "fixed"
    comment: "Element type cannot be changed"
    
  element_id:
    access: "fixed"
    comment: "System-generated unique identifier"
    
  name:
    access: "edit"
    comment: "L2 must provide meaningful name for the node"
    
  node_description:
    access: "fixed"
    comment: "Base description defines element purpose"
    
  description:
    access: "edit"
    comment: "L2 can add context-specific description"
    
  # Schemas - typically fixed to ensure compatibility
  input_schema:
    access: "fixed"
    comment: "Input structure must remain consistent"
    
  output_schema:
    access: "fixed"
    comment: "Output structure must remain consistent"
    
  # Parameters - mixed access levels
  parameters.model:
    access: "fixed"
    comment: "Model fixed to ensure performance and cost predictability"
    
  parameters.temperature:
    access: "edit"
    comment: "L2 can adjust temperature between 0.0-1.0"
    
  parameters.max_tokens:
    access: "edit"
    comment: "L2 can set token limit based on use case"
    
  parameters.stream:
    access: "edit"
    comment: "L2 can enable/disable streaming"
    
  parameters.wrapper_prompt:
    access: "edit"
    comment: "L2 can fully customize the prompt template"
    
  parameters.stop_sequences:
    access: "append"
    comment: "L2 can add stop sequences but not remove defaults"
    
  # Hidden sensitive parameters
  parameters.api_endpoint:
    access: "hidden"
    comment: "Service endpoint hidden for security"
    
  parameters.api_key:
    access: "hidden"
    comment: "API credentials must remain hidden"
    
  parameters.retry_attempts:
    access: "fixed"
    comment: "Retry logic controlled by L1"
    
  parameters.timeout_seconds:
    access: "fixed"
    comment: "Timeout controlled for system stability"
    
  # UI properties
  processing_message:
    access: "edit"
    comment: "L2 can customize user-facing messages"
    
  tags:
    access: "append"
    comment: "L2 can add tags but cannot remove L1 tags"
    
  layer:
    access: "edit"
    comment: "L2 defines visual organization layer"`}
        </CollapsibleCodeBlock>
      </div>
    </Card>
  </TabItem>
</Tabs>

<Callout type="info" title="Key Understanding">
**Parameter Schema Structure** defines WHAT values are valid (types, constraints, enums)

**Hyperparameters** define WHO can modify properties (access levels: fixed, edit, append, hidden)

These are completely separate concerns - constraints belong in the schema, not in hyperparameters.
</Callout>

## Element Properties Deep Dive

### 1. Type

<Card>
  <CardHeader>
    <CardTitle>
      <code>type</code> - Element Category Identifier
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <table>
      <tbody>
        <tr>
          <td><strong>Data Type</strong></td>
          <td><code>string</code></td>
        </tr>
        <tr>
          <td><strong>Defined By</strong></td>
          <td>L1: Element Developer</td>
        </tr>
        <tr>
          <td><strong>Modifiable</strong></td>
          <td>No (always fixed)</td>
        </tr>
        <tr>
          <td><strong>Purpose</strong></td>
          <td>Identifies the element template type</td>
        </tr>
      </tbody>
    </table>
    
    <p style={{ marginTop: '1rem' }}>The type determines the core functionality and behavior of the element. Common types include:</p>
    <ul>
      <li><code>llm_text</code> - AI text generation</li>
      <li><code>llm_structured</code> - Structured AI output</li>
      <li><code>selector</code> - Data extraction</li>
      <li><code>case</code> - Conditional branching</li>
      <li><code>custom</code> - Custom code execution</li>
    </ul>
  </div>
</Card>

### 2. Element ID

<Card>
  <CardHeader>
    <CardTitle>
      <code>element_id</code> - Unique Node Identifier
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <table>
      <tbody>
        <tr>
          <td><strong>Data Type</strong></td>
          <td><code>string</code></td>
        </tr>
        <tr>
          <td><strong>Defined By</strong></td>
          <td>Auto-generated at L2 stage</td>
        </tr>
        <tr>
          <td><strong>Modifiable</strong></td>
          <td>No (system-generated)</td>
        </tr>
        <tr>
          <td><strong>Purpose</strong></td>
          <td>Uniquely identifies node instance in flow</td>
        </tr>
      </tbody>
    </table>
    
    <Callout type="info">
      The element_id is automatically generated when L2 developers create a node from an element template. It serves as both the node's unique identifier and the key in the flow's nodes collection.
    </Callout>
  </div>
</Card>

### 3. Name Properties

<Tabs>
  <TabItem value="name" label="name" default>
    <Card>
      <CardHeader>
        <CardTitle>
          <code>name</code> - Custom Node Name
        </CardTitle>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <table>
          <tbody>
            <tr>
              <td><strong>Data Type</strong></td>
              <td><code>string</code></td>
            </tr>
            <tr>
              <td><strong>Defined By</strong></td>
              <td>L2: Flow Developer</td>
            </tr>
            <tr>
              <td><strong>Purpose</strong></td>
              <td>Human-readable name for the node instance</td>
            </tr>
          </tbody>
        </table>
        
        <p style={{ marginTop: '1rem' }}>Examples:</p>
        <ul>
          <li>"Customer Service AI"</li>
          <li>"Input Validator"</li>
          <li>"Transaction Builder"</li>
        </ul>
      </div>
    </Card>
  </TabItem>
  
  <TabItem value="node_description" label="node_description">
    <Card>
      <CardHeader>
        <CardTitle>
          <code>node_description</code> - Base Element Description
        </CardTitle>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <table>
          <tbody>
            <tr>
              <td><strong>Data Type</strong></td>
              <td><code>string</code></td>
            </tr>
            <tr>
              <td><strong>Defined By</strong></td>
              <td>L1: Element Developer</td>
            </tr>
            <tr>
              <td><strong>Purpose</strong></td>
              <td>Describes what the element type does</td>
            </tr>
          </tbody>
        </table>
        
        <p style={{ marginTop: '1rem' }}>This is the base description that explains the element's functionality. L2 developers see this when selecting elements.</p>
      </div>
    </Card>
  </TabItem>
  
  <TabItem value="description" label="description">
    <Card>
      <CardHeader>
        <CardTitle>
          <code>description</code> - Custom Node Description
        </CardTitle>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <table>
          <tbody>
            <tr>
              <td><strong>Data Type</strong></td>
              <td><code>string</code></td>
            </tr>
            <tr>
              <td><strong>Defined By</strong></td>
              <td>L2: Flow Developer</td>
            </tr>
            <tr>
              <td><strong>Purpose</strong></td>
              <td>Custom description for the specific node instance</td>
            </tr>
          </tbody>
        </table>
        
        <p style={{ marginTop: '1rem' }}>L2 developers can provide context-specific descriptions for their node instances.</p>
      </div>
    </Card>
  </TabItem>
</Tabs>

### 4. Schemas

Schemas define the structure of data flowing in and out of elements:

<Tabs>
  <TabItem value="input" label="Input Schema" default>
    <Card>
      <CardHeader>
        <CardTitle>
          <code>input_schema</code> - Expected Input Structure
        </CardTitle>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <CollapsibleCodeBlock
          title="Input Schema Structure"
          description="How to define input expectations"
          language="yaml"
        >
{`input_schema:
  # Each input variable
  variable_name:
    type: string|int|float|bool|json|list
    required: true|false
    description: "What this input represents"
    # Optional constraints
    default: "default value"
    enum: ["option1", "option2"]
    min_length: 1
    max_length: 100
    minimum: 0
    maximum: 100
    pattern: "regex pattern"
    
  # Example: Chat input with options
  message:
    type: string
    required: true
    description: "User's message"
    max_length: 1000
    
  language:
    type: string
    required: false
    description: "Message language"
    default: "en"
    enum: ["en", "es", "fr", "de"]
    
  options:
    type: json
    required: false
    description: "Additional options"
    default: {}`}
        </CollapsibleCodeBlock>
      </div>
    </Card>
  </TabItem>
  
  <TabItem value="output" label="Output Schema">
    <Card>
      <CardHeader>
        <CardTitle>
          <code>output_schema</code> - Produced Output Structure
        </CardTitle>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <CollapsibleCodeBlock
          title="Output Schema Structure"
          description="How to define output structure"
          language="yaml"
        >
{`output_schema:
  # Each output variable
  variable_name:
    type: string|int|float|bool|json|list
    required: true|false
    description: "What this output contains"
    
  # Example: AI response with metadata
  response:
    type: string
    required: true
    description: "Generated AI response"
    
  confidence:
    type: float
    required: true
    description: "Confidence score (0-1)"
    
  metadata:
    type: json
    required: false
    description: "Additional response metadata"
    
  tokens_used:
    type: int
    required: false
    description: "Number of tokens consumed"`}
        </CollapsibleCodeBlock>
      </div>
    </Card>
  </TabItem>
  
  <TabItem value="parameter" label="Parameter Schema">
    <Card>
      <CardHeader>
        <CardTitle>
          <code>parameter_schema_structure</code> - Parameter Definitions
        </CardTitle>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <CollapsibleCodeBlock
          title="Parameter Schema Structure"
          description="Defining configurable parameters"
          language="yaml"
        >
{`parameter_schema_structure:
  # Each parameter with its constraints
  parameter_name:
    type: string|int|float|bool|json|list
    # Type-specific constraints
    enum: ["option1", "option2"]  # For string
    min: 0                         # For numbers
    max: 100
    pattern: "regex"               # For string
    
  # Example: LLM configuration
  model:
    type: string
    enum: ["llama-3.3-70b", "deepseek-r1", "claude-3"]
    
  temperature:
    type: float
    min: 0.0
    max: 1.0
    
  max_tokens:
    type: int
    min: 1
    max: 8000
    
  response_format:
    type: string
    enum: ["text", "json", "markdown"]`}
        </CollapsibleCodeBlock>
      </div>
    </Card>
  </TabItem>
</Tabs>

### 5. Parameters

<Card>
  <CardHeader>
    <CardTitle>
      <code>parameters</code> - Configuration Values
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <p>Parameters are the actual configuration values for the element, mapping parameter names to their values:</p>
    
    <CollapsibleCodeBlock
      title="Parameters Example"
      description="How parameters map to values"
      language="yaml"
    >
{`parameters:
  # L1 defined defaults
  model: "llama-3.3-70b"
  temperature: 0.7
  max_tokens: 1000
  
  # Hidden parameters (via hyperparameters)
  api_key: "\$\{AWS_BEDROCK_KEY}"
  api_endpoint: "https://bedrock.amazonaws.com"
  
  # L2 customizable (if allowed by hyperparameters)
  wrapper_prompt: |
    You are a helpful assistant.
    User: {prompt}
    Assistant:
  
  response_format: "text"
  streaming: true`}
    </CollapsibleCodeBlock>
    
    <Callout type="info">
      Which parameters can be modified by L2 is controlled by the hyperparameters configuration.
    </Callout>
  </div>
</Card>

### 6. UI/UX Properties

<Features>
  <Feature title="processing_message" icon="/img/icons/terminal.svg">
    Message displayed while the node is executing
  </Feature>
  <Feature title="tags" icon="/img/icons/database.svg">
    Organizational tags for categorization and search
  </Feature>
  <Feature title="layer" icon="/img/icons/network.svg">
    Logical grouping layer for visual organization
  </Feature>
</Features>

<CollapsibleCodeBlock
  title="UI/UX Properties Example"
  description="Enhancing user experience"
  language="yaml"
>
{`# Processing message shown during execution
processing_message: "Analyzing sentiment..."  # L1 default
processing_message: "Processing your request..."  # L2 customized

# Tags for organization
tags: 
  # L1 base tags
  - "ai"
  - "text-analysis"
  # L2 additional tags (if hyperparameter allows append)
  - "customer-service"
  - "sentiment"
  
# Layer for visual grouping (L2 defined)
layer: "preprocessing"  # or "ai-processing", "output-generation"`}
</CollapsibleCodeBlock>

### 7. Special Properties

<Tabs>
  <TabItem value="code" label="Code Property" default>
    <Card>
      <CardHeader>
        <CardTitle>
          <code>code</code> - Custom Code Execution
        </CardTitle>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <p>Used primarily in custom elements to define executable Python code:</p>
        
        <CollapsibleCodeBlock
          title="Code Property Example"
          language="python"
        >
{`code: |
  # Access inputs
  user_data = inputs.get('user_data', {})
  threshold = inputs.get('threshold', 0.5)
  
  # Access parameters
  multiplier = parameters.get('multiplier', 2)
  
  # Process data
  result = {}
  for key, value in user_data.items():
      if isinstance(value, (int, float)):
          result[key] = value * multiplier
      else:
          result[key] = value
          
  # Set outputs
  output['processed_data'] = result
  output['above_threshold'] = any(
      v > threshold for v in result.values() 
      if isinstance(v, (int, float))
  )`}
        </CollapsibleCodeBlock>
        
        <Callout type="warning">
          Code execution is sandboxed with resource limits. The hyperparameters control whether L2 can modify the code.
        </Callout>
      </div>
    </Card>
  </TabItem>
  
  <TabItem value="flow_control" label="Flow Control">
    <Card>
      <CardHeader>
        <CardTitle>
          <code>flow_control</code> - Control Flow Configuration
        </CardTitle>
      </CardHeader>
      <div style={{ padding: '1rem' }}>
        <p>Used in flow control elements (case, flow_select) to define branching logic:</p>
        
        <CollapsibleCodeBlock
          title="Flow Control Example"
          language="yaml"
        >
{`flow_control:
  # For case elements
  cases:
    - high_priority:
        condition:
          variable1: "priority_score"
          variable2: 0.8
          operator: ">="
        enable_connections: ["urgent_handler"]
        disable_connections: ["normal_handler"]
        
    - medium_priority:
        condition:
          variable1: "priority_score"
          variable2: 0.5
          operator: ">="
        enable_connections: ["normal_handler"]
        
  # For flow_select elements
  flow_options:
    - id: "payment_flow"
      condition: "intent == 'payment'"
    - id: "support_flow"
      condition: "intent == 'support'"
    - id: "default_flow"
      condition: "true"`}
        </CollapsibleCodeBlock>
      </div>
    </Card>
  </TabItem>
</Tabs>

## Hyperparameters: The Control System

Hyperparameters are the most critical part of an element definition. They define the rules for how L2 developers can customize elements when creating nodes.

<Card>
  <CardHeader>
    <CardTitle>Understanding Hyperparameters</CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <p>Hyperparameters map each element property to an access control configuration:</p>
    
    <table>
      <thead>
        <tr>
          <th>Access Level</th>
          <th>Description</th>
          <th>L2 Capabilities</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>fixed</code></td>
          <td>Cannot be modified</td>
          <td>Read-only, uses L1 value</td>
        </tr>
        <tr>
          <td><code>edit</code></td>
          <td>Full control</td>
          <td>Can modify, delete, or set new value</td>
        </tr>
        <tr>
          <td><code>append</code></td>
          <td>Can add but not remove</td>
          <td>Add to L1 values (e.g., tags)</td>
        </tr>
        <tr>
          <td><code>hidden</code></td>
          <td>Present but not visible</td>
          <td>Value used but not shown to L2/L3</td>
        </tr>
      </tbody>
    </table>
  </div>
</Card>

<CollapsibleCodeBlock
  title="Complete Hyperparameters Example"
  description="Comprehensive hyperparameter configuration"
  language="yaml"
  defaultCollapsed={false}
>
{`hyperparameters:
  # Core properties - typically fixed
  type:
    access: "fixed"
    comment: "Element type is immutable"
    
  element_id:
    access: "fixed"
    comment: "System-generated, cannot be changed"
    
  # Naming - typically editable
  name:
    access: "edit"
    comment: "L2 must provide meaningful name"
    
  description:
    access: "edit"
    comment: "L2 can customize description"
    
  # Schemas - depends on element design
  input_schema:
    access: "fixed"
    comment: "Input structure defined by L1"
    
  output_schema:
    access: "fixed"
    comment: "Output structure defined by L1"
    
  # Could also be editable for flexible elements
  # input_schema:
  #   access: "edit"
  #   comment: "L2 can define custom inputs"
    
  # Parameters - granular control
  parameters.model:
    access: "fixed"
    comment: "Model fixed to ensure compatibility"
    
  parameters.temperature:
    access: "edit"
    comment: "L2 can adjust creativity (0.0-1.0)"
      
  parameters.api_key:
    access: "hidden"
    comment: "API credentials hidden from L2/L3"
    
  parameters.custom_prompt:
    access: "edit"
    comment: "L2 can define custom prompts"
    
  # Organization
  tags:
    access: "append"
    comment: "L2 can add tags, cannot remove L1 tags"
    base_tags: ["ai", "llm"]
    
  layer:
    access: "edit"
    comment: "L2 defines organizational layer"
    
  # Special properties
  code:
    access: "fixed"  # or "edit" for customizable elements
    comment: "Code logic defined by L1"
    
  processing_message:
    access: "edit"
    comment: "L2 can customize user-facing messages"`}
</CollapsibleCodeBlock>

### Hyperparameter Use Cases

<Tabs>
  <TabItem value="fixed-element" label="Fixed Element" default>
    <div style={{ marginTop: '1rem' }}>
      <h4>Highly Controlled Element</h4>
      <p>For critical or security-sensitive elements:</p>
      
      <CollapsibleCodeBlock
        title="Fixed Element Example"
        language="yaml"
      >
{`# Blockchain transaction element
hyperparameters:
  input_schema:
    access: "fixed"
    comment: "Transaction structure must be exact"
  output_schema:
    access: "fixed"
  parameters.network:
    access: "fixed"
    comment: "Network cannot be changed"
  parameters.contract_address:
    access: "fixed"
    comment: "Contract is pre-verified"
  parameters.gas_limit:
    access: "edit"
    comment: "L2 can optimize gas usage"
    `}
      </CollapsibleCodeBlock>
    </div>
  </TabItem>
  
  <TabItem value="flexible-element" label="Flexible Element">
    <div style={{ marginTop: '1rem' }}>
      <h4>Customizable Element</h4>
      <p>For elements requiring flexibility:</p>
      
      <CollapsibleCodeBlock
        title="Flexible Element Example"
        language="yaml"
      >
{`# Custom code element
hyperparameters:
  input_schema:
    access: "edit"
    comment: "L2 defines inputs"
  output_schema:
    access: "edit"
    comment: "L2 defines outputs"
  code:
    access: "edit"
    comment: "L2 writes custom logic"
  parameters.timeout:
    access: "edit"
    constraints:
      min: 100
      max: 30000
  parameters.memory_limit:
    access: "edit"
`}
      </CollapsibleCodeBlock>
    </div>
  </TabItem>
  
  <TabItem value="mixed-element" label="Mixed Control">
    <div style={{ marginTop: '1rem' }}>
      <h4>Balanced Control Element</h4>
      <p>Common pattern with mixed control levels:</p>
      
      <CollapsibleCodeBlock
        title="Mixed Control Example"
        language="yaml"
      >
{`# AI element with customization
hyperparameters:
  # Fixed core behavior
  type: { access: "fixed" }
  input_schema: { access: "fixed" }
  output_schema: { access: "fixed" }
  parameters.model: { access: "fixed" }
  
  # Hidden sensitive data
  parameters.api_key: { access: "hidden" }
  parameters.endpoint: { access: "hidden" }
  
  # Customizable behavior
  parameters.temperature: 
    access: "edit"
  parameters.system_prompt:
    access: "edit"
  
  # Appendable metadata
  tags:
    access: "append"
    base_tags: ["ai", "production"]`}
      </CollapsibleCodeBlock>
    </div>
  </TabItem>
</Tabs>

## Input and Output Runtime Values

<Card>
  <CardHeader>
    <CardTitle>Runtime Data Flow</CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <table>
      <thead>
        <tr>
          <th>Property</th>
          <th>When Set</th>
          <th>Purpose</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>input</code></td>
          <td>L3 (User) or L4 (Runtime)</td>
          <td>Actual values provided to the node during execution</td>
        </tr>
        <tr>
          <td><code>output</code></td>
          <td>L4 (Runtime)</td>
          <td>Values produced by the node after execution</td>
        </tr>
      </tbody>
    </table>
    
    <CollapsibleCodeBlock
      title="Runtime Example"
      description="How inputs flow to outputs"
      language="yaml"
    >
{`# L3 provides input
input:
  prompt: "What is machine learning?"
  temperature: 0.5  # Overrides default if allowed
  
# L4 executes and produces output
output:
  llm_output: "Machine learning is a subset of AI..."
  tokens_used: 127
  execution_time_ms: 1234`}
    </CollapsibleCodeBlock>
  </div>
</Card>

## Best Practices for Element Design

<Features>
  <Feature title="Clear Schemas" icon="/img/icons/docs.svg">
    Define comprehensive schemas with descriptions and constraints
  </Feature>
  <Feature title="Thoughtful Hyperparameters" icon="/img/icons/security.svg">
    Balance flexibility with safety using appropriate access levels
  </Feature>
  <Feature title="Meaningful Defaults" icon="/img/icons/success.svg">
    Provide sensible default values that work out-of-the-box
  </Feature>
</Features>

### Element Design Checklist

<Callout type="success" title="Element Design Best Practices">
✅ **Clear Purpose**: Each element should have a single, well-defined responsibility

✅ **Complete Schemas**: Define all inputs/outputs with types and descriptions

✅ **Appropriate Access**: Use hyperparameters to control customization appropriately

✅ **Hidden Secrets**: Keep sensitive data (API keys) hidden from L2/L3

✅ **Validation Rules**: Include constraints in schemas and parameter structures

✅ **Helpful Defaults**: Provide working defaults for optional parameters

✅ **Documentation**: Use descriptions and comments liberally

✅ **Error Handling**: Design for graceful failure with clear error messages
</Callout>

## Summary

Elements are sophisticated templates that encapsulate functionality while providing controlled customization through hyperparameters. Understanding each property and how they interact is crucial for:

- **L1 Developers**: Creating reusable, secure, and flexible element templates
- **L2 Developers**: Understanding what can be customized when creating nodes
- **System Understanding**: Grasping how the multi-level architecture maintains security and flexibility

The hyperparameter system is the key innovation that allows elements to be both powerful and secure, giving L1 developers fine-grained control over what L2 developers can modify while hiding sensitive implementation details.

## Next Steps

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginTop: '1.5rem' }}>
  <Card>
    <CardHeader>
      <CardTitle>Element Reference</CardTitle>
      <CardDescription>
        Explore all available element types
      </CardDescription>
    </CardHeader>
    <div style={{ padding: '1rem', paddingTop: 0 }}>
      <a href="/docs/hpc-neura-execution-engine/element-reference" style={{ textDecoration: 'none' }}>
        View element catalog →
      </a>
    </div>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Creating Custom Elements</CardTitle>
      <CardDescription>
        Guide for L1 developers
      </CardDescription>
    </CardHeader>
    <div style={{ padding: '1rem', paddingTop: 0 }}>
      <a href="/docs/hpc-neura-execution-engine/creating-elements" style={{ textDecoration: 'none' }}>
        Build elements →
      </a>
    </div>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Using Elements</CardTitle>
      <CardDescription>
        Guide for L2 developers
      </CardDescription>
    </CardHeader>
    <div style={{ padding: '1rem', paddingTop: 0 }}>
      <a href="/docs/hpc-neura-execution-engine/using-elements" style={{ textDecoration: 'none' }}>
        Create nodes →
      </a>
    </div>
  </Card>
</div>