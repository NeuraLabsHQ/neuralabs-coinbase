---
id: hpc-flows
title: Flows
sidebar_label: Flows
sidebar_position: 2
---

import { Card, CardHeader, CardTitle, CardDescription } from '@site/src/components/Card';
import { Callout } from '@site/src/components/Callout';
import { Features, Feature } from '@site/src/components/Features';
import { CollapsibleCodeBlock, InlineCodeCard } from '@site/src/components/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

# Flows

Flows are the complete workflow definitions that orchestrate the execution of connected nodes in the HPC Neura Execution Engine. Created by L2 developers, flows define how data moves through a series of operations to achieve a specific goal.

<Callout type="info">
A flow is a directed acyclic graph (DAG) where nodes perform operations and connections define data pathways between them.
</Callout>

## Flow Anatomy

Every flow consists of seven core components that work together to create an executable workflow:

<Card>
  <CardHeader>
    <CardTitle>Complete Flow Structure</CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <CollapsibleCodeBlock
      title="Full Flow Definition Example"
      description="A complete flow with all components"
      language="yaml"
      defaultCollapsed={false}
    >
{`# Example: Customer Service AI Flow
flow_id: "flow_cs_ai_20250127_abc123"  # System-generated

# 1. INPUTS - Initial data mapped to nodes
inputs:
  chat_input_001:
    "chat_input_001:message": "I need help with my order"
    "chat_input_001:language": "en"
  
  config_001:
    "config_001:temperature": 0.3
    "config_001:response_style": "professional"
    
  user_data_001:
    "user_data_001:customer_tier": "premium"

# 2. NODES - Instances created from elements
nodes:
  # Entry point
  start_001:
    type: "start"
    element_id: "start_001"
    name: "Flow Start"
    description: "Customer service flow entry"
    
  # User input
  chat_input_001:
    type: "chat_input"
    element_id: "chat_input_001"
    name: "Customer Message"
    description: "Captures customer inquiry"
    output_schema:
      message:
        type: string
        required: true
      language:
        type: string
        required: false
        
  # Configuration node
  config_001:
    type: "constants"
    element_id: "config_001"
    name: "AI Configuration"
    parameters:
      temperature: 0.3
      response_style: "professional"
      
  # Customer data
  user_data_001:
    type: "metadata"
    element_id: "user_data_001"
    name: "Customer Context"
    
  # AI processor
  ai_processor_001:
    type: "llm_structured"
    element_id: "ai_processor_001"
    name: "Intent Analyzer"
    description: "Analyzes customer intent"
    input_schema:
      message:
        type: string
        required: true
      context:
        type: json
        required: true
    output_schema:
      intent:
        type: string
        required: true
      urgency:
        type: string
        enum: ["low", "medium", "high"]
      suggested_action:
        type: string
    parameters:
      model: "llama-3.3-70b"
      temperature: 0.3
      max_tokens: 500
      
  # Response generator
  response_gen_001:
    type: "llm_text"
    element_id: "response_gen_001"
    name: "Response Generator"
    parameters:
      model: "llama-3.3-70b"
      wrapper_prompt: |
        You are a professional customer service agent.
        Customer tier: {customer_tier}
        Intent: {intent}
        Urgency: {urgency}
        
        Provide a helpful response to: {message}
        
  # Exit point
  end_001:
    type: "end"
    element_id: "end_001"
    name: "Flow End"
    input_schema:
      text_input:
        type: string
        required: true
      metadata:
        type: json
        required: false

# 3. CONNECTIONS - Data flow definitions
connections:
  # Start connections
  - from_id: "start_001"
    to_id: "chat_input_001"
    
  - from_id: "start_001"
    to_id: "config_001"
    
  - from_id: "start_001"
    to_id: "user_data_001"
    
  # Data flow to AI processor
  - from_id: "chat_input_001"
    to_id: "ai_processor_001"
    from_output: "chat_input_001:message"
    to_input: "ai_processor_001:message"
    
  - from_id: "user_data_001"
    to_id: "ai_processor_001"
    from_output: "user_data_001:customer_tier"
    to_input: "ai_processor_001:context.customer_tier"
    
  # AI processor to response generator
  - from_id: "ai_processor_001"
    to_id: "response_gen_001"
    from_output: "ai_processor_001:intent"
    to_input: "response_gen_001:intent"
    
  - from_id: "ai_processor_001"
    to_id: "response_gen_001"
    from_output: "ai_processor_001:urgency"
    to_input: "response_gen_001:urgency"
    
  - from_id: "chat_input_001"
    to_id: "response_gen_001"
    from_output: "chat_input_001:message"
    to_input: "response_gen_001:message"
    
  - from_id: "user_data_001"
    to_id: "response_gen_001"
    from_output: "user_data_001:customer_tier"
    to_input: "response_gen_001:customer_tier"
    
  # Response to end
  - from_id: "response_gen_001"
    to_id: "end_001"
    from_output: "response_gen_001:llm_output"
    to_input: "end_001:text_input"
    
  - from_id: "ai_processor_001"
    to_id: "end_001"
    from_output: "ai_processor_001:suggested_action"
    to_input: "end_001:metadata.suggested_action"

# 4. START ELEMENT - Entry point
start_element: "start_001"

# 5. METADATA - Execution context
metadata:
  execution_context:
    # L3 User information
    user_id: "user_789xyz"
    user_name: "John Doe"
    user_email: "john.doe@example.com"
    wallet_address: "0x742d35Cc6634C0532925a3b844Bc9e7595f6E123"
    
    # Session information
    session_id: "session_456def"
    session_count: 12
    last_interaction: "2025-01-27T09:30:00Z"
    
    # Execution environment
    environment: "production"
    region: "us-east-1"
    execution_start: "2025-01-27T10:00:00Z"
    
    # Custom context
    feature_flags:
      premium_support: true
      ai_suggestions: true
      blockchain_integration: false
      
  # Flow-level configuration
  flow_config:
    timeout_seconds: 300
    max_retries: 3
    stream_responses: true
    
  # Flow metadata
  flow_info:
    name: "Customer Service AI Assistant"
    description: "Intelligent customer support with intent analysis"
    version: "2.1.0"
    tags: ["customer-service", "ai", "production"]
    
# 6. OUTPUT - Defined by end node(s)
# The flow output is whatever the end node produces

# 7. Additional flow properties (optional)
config:
  # Execution configuration
  execution:
    parallel_limit: 5
    memory_limit_mb: 512
    cpu_limit: 2.0
    
  # Error handling
  error_handling:
    on_node_failure: "stop"  # or "continue", "retry"
    notification_webhook: "https://api.example.com/flow-errors"
    
  # Access control
  permissions:
    execute: ["role:customer_service", "user:admin"]
    view: ["role:supervisor", "role:customer_service"]
    modify: ["user:flow_developer"]`}
    </CollapsibleCodeBlock>
  </div>
</Card>

## Flow Components Deep Dive

### 1. Flow ID

<Card>
  <CardHeader>
    <CardTitle>
      <code>flow_id</code> - Unique Flow Identifier
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <table>
      <tbody>
        <tr>
          <td><strong>Type</strong></td>
          <td><code>string</code></td>
        </tr>
        <tr>
          <td><strong>Generated By</strong></td>
          <td>System (automatic)</td>
        </tr>
        <tr>
          <td><strong>Format</strong></td>
          <td><code>flow_[purpose]_[timestamp]_[random]</code></td>
        </tr>
        <tr>
          <td><strong>Purpose</strong></td>
          <td>Uniquely identifies flow instance</td>
        </tr>
      </tbody>
    </table>
    
    <p style={{ marginTop: '1rem' }}>Examples:</p>
    <ul>
      <li><code>flow_cs_ai_20250127_abc123</code></li>
      <li><code>flow_payment_20250127_xyz789</code></li>
      <li><code>flow_analytics_20250127_def456</code></li>
    </ul>
    
    <Callout type="info">
      Flow IDs are immutable once generated and serve as the primary key for flow storage and execution tracking.
    </Callout>
  </div>
</Card>

### 2. Inputs

<Card>
  <CardHeader>
    <CardTitle>
      <code>inputs</code> - Initial Flow Data
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <p>Inputs provide initial data to nodes at flow start. They follow a specific structure:</p>
    
    <CollapsibleCodeBlock
      title="Input Structure"
      description="How inputs are organized by node"
      language="yaml"
    >
{`inputs:
  # Grouped by node_id
  node_id_1:
    "node_id_1:variable_name": value
    "node_id_1:another_var": value
    
  node_id_2:
    "node_id_2:config_param": value
    "node_id_2:threshold": 0.8
    
  # Real example
  chat_processor_001:
    "chat_processor_001:message": "Hello, I need help"
    "chat_processor_001:language": "en"
    "chat_processor_001:max_length": 500
    
  user_context_001:
    "user_context_001:user_tier": "premium"
    "user_context_001:history_count": 5`}
    </CollapsibleCodeBlock>
    
    <Features>
      <Feature title="Node Scoping" icon="/img/icons/network.svg">
        Each node only receives its designated inputs
      </Feature>
      <Feature title="Type Safety" icon="/img/icons/security.svg">
        Input values must match node schema types
      </Feature>
      <Feature title="Override Defaults" icon="/img/icons/settings.svg">
        Inputs override node default values
      </Feature>
    </Features>
  </div>
</Card>

### 3. Nodes

<Card>
  <CardHeader>
    <CardTitle>
      <code>nodes</code> - Workflow Operations
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <p>Nodes are instances of elements that perform the actual work in a flow:</p>
    
    <table>
      <thead>
        <tr>
          <th>Property</th>
          <th>Description</th>
          <th>Set By</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Node ID</td>
          <td>Unique identifier within flow</td>
          <td>L2 (auto-generated)</td>
        </tr>
        <tr>
          <td>Type</td>
          <td>Element type being instantiated</td>
          <td>L1 (from element)</td>
        </tr>
        <tr>
          <td>Configuration</td>
          <td>Custom parameters and settings</td>
          <td>L2 (per hyperparameters)</td>
        </tr>
        <tr>
          <td>Runtime Data</td>
          <td>Inputs and outputs during execution</td>
          <td>L3/L4</td>
        </tr>
      </tbody>
    </table>
    
    <Callout type="tip">
      Nodes inherit their base behavior from elements but can be customized according to the element's hyperparameter rules.
    </Callout>
  </div>
</Card>

### 4. Connections

<Card>
  <CardHeader>
    <CardTitle>
      <code>connections</code> - Data Flow Paths
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <p>Connections define how data flows between nodes. Each connection is a mapping with four properties:</p>
    
    <CollapsibleCodeBlock
      title="Connection Structure"
      description="Anatomy of a connection"
      language="yaml"
    >
{`# Connection structure
{
  from_id: "source_node_id",
  to_id: "target_node_id",
  from_output: "source_node_id:output_variable",  # Optional
  to_input: "target_node_id:input_variable"       # Optional
}

# Examples:

# 1. Simple connection (all outputs to all inputs)
- from_id: "start_001"
  to_id: "processor_001"
  
# 2. Specific field mapping
- from_id: "analyzer_001"
  to_id: "formatter_001"
  from_output: "analyzer_001:sentiment_score"
  to_input: "formatter_001:score"
  
# 3. Multiple outputs from one node
- from_id: "splitter_001"
  to_id: "path_a_001"
  from_output: "splitter_001:data_a"
  to_input: "path_a_001:input_data"
  
- from_id: "splitter_001"
  to_id: "path_b_001"
  from_output: "splitter_001:data_b"
  to_input: "path_b_001:input_data"
  
# 4. Nested data mapping
- from_id: "api_response_001"
  to_id: "processor_001"
  from_output: "api_response_001:response.data.items[0]"
  to_input: "processor_001:first_item"`}
    </CollapsibleCodeBlock>
    
    <Features>
      <Feature title="Type Checking" icon="/img/icons/success.svg">
        Connection types are validated at flow creation
      </Feature>
      <Feature title="DAG Enforcement" icon="/img/icons/warning.svg">
        Circular dependencies are detected and prevented
      </Feature>
      <Feature title="Parallel Paths" icon="/img/icons/hpc.svg">
        Multiple connections enable parallel execution
      </Feature>
    </Features>
  </div>
</Card>

### 5. Start Element

<Card>
  <CardHeader>
    <CardTitle>
      <code>start_element</code> - Flow Entry Point
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <table>
      <tbody>
        <tr>
          <td><strong>Type</strong></td>
          <td><code>string</code> (node_id)</td>
        </tr>
        <tr>
          <td><strong>Purpose</strong></td>
          <td>Identifies which node begins execution</td>
        </tr>
        <tr>
          <td><strong>Constraints</strong></td>
          <td>Must be a start-type node</td>
        </tr>
      </tbody>
    </table>
    
    <p style={{ marginTop: '1rem' }}>The start element is typically a node of type <code>start</code> that:</p>
    <ul>
      <li>Has no incoming connections</li>
      <li>Receives initial flow inputs</li>
      <li>Triggers execution of connected nodes</li>
    </ul>
    
    <InlineCodeCard
      title="Start Element Example"
      language="yaml"
      code={`start_element: "start_001"  # References the start node`}
    />
  </div>
</Card>

### 6. Metadata

<Card>
  <CardHeader>
    <CardTitle>
      <code>metadata</code> - Execution Context & Configuration
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <p>Metadata contains runtime context and flow configuration:</p>
    
    <Tabs>
      <TabItem value="execution_context" label="Execution Context" default>
        <div style={{ marginTop: '1rem' }}>
          <CollapsibleCodeBlock
            title="Execution Context Structure"
            description="L3 user and session information"
            language="yaml"
          >
{`metadata:
  execution_context:
    # User Information (L3)
    user_id: "user_unique_id"
    user_name: "John Doe"
    user_email: "john@example.com"
    user_role: "premium_customer"
    wallet_address: "0x742d35Cc..."
    
    # Session Information
    session_id: "session_unique_id"
    session_count: 15
    last_interaction: "2025-01-27T09:30:00Z"
    ip_address: "192.168.1.1"
    user_agent: "Mozilla/5.0..."
    
    # Execution Environment
    environment: "production"
    region: "us-east-1"
    execution_id: "exec_unique_id"
    execution_start: "2025-01-27T10:00:00Z"
    
    # Feature Flags
    feature_flags:
      beta_features: true
      enhanced_ai: true
      debug_mode: false
      
    # Custom Context
    custom_data:
      department: "sales"
      project: "customer_success"
      cost_center: "CS-001"`}
          </CollapsibleCodeBlock>
          
          <Callout type="info">
            The execution context is automatically injected into metadata nodes and available throughout the flow.
          </Callout>
        </div>
      </TabItem>
      
      <TabItem value="flow_config" label="Flow Configuration">
        <div style={{ marginTop: '1rem' }}>
          <CollapsibleCodeBlock
            title="Flow Configuration Options"
            description="Runtime behavior settings"
            language="yaml"
          >
{`metadata:
  flow_config:
    # Execution limits
    timeout_seconds: 300
    max_retries: 3
    retry_delay_ms: 1000
    
    # Performance settings
    parallel_execution: true
    max_parallel_nodes: 10
    stream_responses: true
    
    # Memory management
    max_memory_mb: 1024
    garbage_collection: "aggressive"
    
    # Monitoring
    trace_execution: true
    log_level: "info"
    metrics_enabled: true
    
    # Error behavior
    continue_on_error: false
    error_notification: true`}
          </CollapsibleCodeBlock>
        </div>
      </TabItem>
      
      <TabItem value="flow_info" label="Flow Information">
        <div style={{ marginTop: '1rem' }}>
          <CollapsibleCodeBlock
            title="Flow Metadata"
            description="Descriptive information about the flow"
            language="yaml"
          >
{`metadata:
  flow_info:
    # Basic information
    name: "Customer Service AI Assistant"
    description: "Intelligent support with intent analysis"
    version: "2.1.0"
    
    # Organization
    tags: ["customer-service", "ai", "production"]
    category: "support"
    owner: "customer-success-team"
    
    # Versioning
    created_at: "2025-01-15T10:00:00Z"
    updated_at: "2025-01-27T09:00:00Z"
    changelog: "Added urgency detection"`}
          </CollapsibleCodeBlock>
        </div>
      </TabItem>
    </Tabs>
  </div>
</Card>

### 7. Output

<Card>
  <CardHeader>
    <CardTitle>
      <code>output</code> - Flow Results
    </CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <p>Flow output is determined by the end node(s) in the flow:</p>
    
    <Features>
      <Feature title="End Node Output" icon="/img/icons/arrow-right.svg">
        The output is exactly what the end node produces
      </Feature>
      <Feature title="Multiple Ends" icon="/img/icons/network.svg">
        Flows can have multiple end nodes for different paths
      </Feature>
      <Feature title="Structured Results" icon="/img/icons/docs.svg">
        End nodes define their output schema
      </Feature>
    </Features>
    
    <CollapsibleCodeBlock
      title="Output Examples"
      description="Different types of flow outputs"
      language="yaml"
    >
{`# Simple text output
output:
  text_output: "Your request has been processed successfully."
  
# Structured output with metadata
output:
  text_output: "Order confirmed"
  metadata:
    order_id: "ORD-12345"
    estimated_delivery: "2025-01-30"
    tracking_url: "https://track.example.com/ORD-12345"
    
# Transaction output
output:
  text_output: "Transaction prepared"
  proposed_transaction:
    to: "0x742d35Cc..."
    value: "100"
    data: "0x..."
    gas_limit: 21000
    
# Multi-path output (conditional flows)
output:
  text_output: "Analysis complete"
  path_taken: "high_priority"
  results:
    sentiment: "negative"
    urgency: "high"
    suggested_actions: ["escalate", "follow_up"]`}
    </CollapsibleCodeBlock>
  </div>
</Card>

## Additional Flow Properties

### Configuration Options

<Card>
  <CardHeader>
    <CardTitle>Flow-Level Configuration</CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <p>Flows can include additional configuration for advanced scenarios:</p>
    
    <CollapsibleCodeBlock
      title="Advanced Configuration"
      description="Optional flow-level settings"
      language="yaml"
    >
{`config:
  # Execution behavior
  execution:
    mode: "streaming"  # or "batch"
    priority: "high"   # low, medium, high
    queue: "premium"   # routing queue
    
  # Resource limits
  resources:
    cpu_cores: 2
    memory_gb: 4
    gpu_enabled: false
    timeout_seconds: 300
    
  # Retry policy
  retry_policy:
    max_attempts: 3
    backoff_type: "exponential"
    initial_delay_ms: 1000
    max_delay_ms: 30000
    
  # Monitoring
  monitoring:
    trace_enabled: true
    metrics_endpoint: "https://metrics.example.com"
    alert_thresholds:
      duration_ms: 5000
      error_rate: 0.05
      
  # Security
  security:
    encrypt_data: true
    audit_logging: true
    compliance_mode: "pci"
    
  # Webhooks
  webhooks:
    on_start: "https://api.example.com/flow-start"
    on_complete: "https://api.example.com/flow-complete"
    on_error: "https://api.example.com/flow-error"`}
    </CollapsibleCodeBlock>
  </div>
</Card>

### Access Control

<Features>
  <Feature title="Execute Permissions" icon="/img/icons/security.svg">
    Control who can run the flow
  </Feature>
  <Feature title="View Permissions" icon="/img/icons/docs.svg">
    Manage flow visibility
  </Feature>
  <Feature title="Modify Permissions" icon="/img/icons/settings.svg">
    Restrict flow editing
  </Feature>
</Features>

## Flow Design Patterns

### Sequential Processing

<CollapsibleCodeBlock
  title="Sequential Flow Pattern"
  description="Step-by-step processing"
  language="yaml"
>
{`connections:
  - from_id: "start"
    to_id: "validate"
  - from_id: "validate"
    to_id: "process"
  - from_id: "process"
    to_id: "format"
  - from_id: "format"
    to_id: "end"`}
</CollapsibleCodeBlock>

### Parallel Processing

<CollapsibleCodeBlock
  title="Parallel Flow Pattern"
  description="Concurrent execution paths"
  language="yaml"
>
{`connections:
  # Fan-out
  - from_id: "distributor"
    to_id: "processor_a"
  - from_id: "distributor"
    to_id: "processor_b"
  - from_id: "distributor"
    to_id: "processor_c"
  
  # Fan-in
  - from_id: "processor_a"
    to_id: "aggregator"
  - from_id: "processor_b"
    to_id: "aggregator"
  - from_id: "processor_c"
    to_id: "aggregator"`}
</CollapsibleCodeBlock>

### Conditional Routing

<CollapsibleCodeBlock
  title="Conditional Flow Pattern"
  description="Dynamic path selection"
  language="yaml"
>
{`nodes:
  router:
    type: "case"
    cases:
      - premium: "customer_tier == 'premium'"
      - standard: "customer_tier == 'standard'"
      
connections:
  - from_id: "router"
    to_id: "premium_handler"
    # Enabled only for premium case
  - from_id: "router"
    to_id: "standard_handler"
    # Enabled only for standard case`}
</CollapsibleCodeBlock>

## Best Practices

<Callout type="success" title="Flow Design Best Practices">
✅ **Clear Naming**: Use descriptive node IDs and names
✅ **Modular Design**: Keep nodes focused on single responsibilities
✅ **Error Handling**: Include error paths and validation nodes
✅ **Documentation**: Use descriptions for flows and nodes
✅ **Version Control**: Track flow versions and changes
✅ **Testing**: Test all paths including edge cases
✅ **Performance**: Design for parallel execution where possible
✅ **Security**: Validate inputs and handle sensitive data properly
</Callout>

## Flow Validation

The engine performs comprehensive validation:

<Card>
  <CardHeader>
    <CardTitle>Validation Checks</CardTitle>
  </CardHeader>
  <div style={{ padding: '1rem' }}>
    <table>
      <thead>
        <tr>
          <th>Check</th>
          <th>Description</th>
          <th>When</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Schema Compatibility</td>
          <td>Input/output types match</td>
          <td>Flow creation</td>
        </tr>
        <tr>
          <td>DAG Validation</td>
          <td>No circular dependencies</td>
          <td>Flow creation</td>
        </tr>
        <tr>
          <td>Required Inputs</td>
          <td>All required inputs connected</td>
          <td>Flow creation</td>
        </tr>
        <tr>
          <td>Node Configuration</td>
          <td>Valid parameters per hyperparameters</td>
          <td>Node creation</td>
        </tr>
        <tr>
          <td>Start Element</td>
          <td>Valid start node exists</td>
          <td>Flow creation</td>
        </tr>
        <tr>
          <td>End Reachability</td>
          <td>At least one path to end</td>
          <td>Flow creation</td>
        </tr>
      </tbody>
    </table>
  </div>
</Card>

## Summary

Flows are sophisticated workflow definitions that bring together nodes, connections, and configuration to create executable processes. Key points:

- **Structure**: Seven core components work together
- **Flexibility**: Nodes can be customized per element rules
- **Data Flow**: Connections define precise data routing
- **Context**: Metadata provides runtime information
- **Control**: Configuration options for advanced scenarios

Understanding flow structure is essential for L2 developers creating workflows and L3 users interacting with them.

## Next Steps

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginTop: '1.5rem' }}>
  <Card>
    <CardHeader>
      <CardTitle>Building Flows</CardTitle>
      <CardDescription>
        Step-by-step guide to creating flows
      </CardDescription>
    </CardHeader>
    <div style={{ padding: '1rem', paddingTop: 0 }}>
      <a href="/docs/hpc-neura-execution-engine/building-flows" style={{ textDecoration: 'none' }}>
        Start building →
      </a>
    </div>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Flow Examples</CardTitle>
      <CardDescription>
        Real-world flow patterns and templates
      </CardDescription>
    </CardHeader>
    <div style={{ padding: '1rem', paddingTop: 0 }}>
      <a href="/docs/hpc-neura-execution-engine/examples" style={{ textDecoration: 'none' }}>
        Browse examples →
      </a>
    </div>
  </Card>
  
  <Card>
    <CardHeader>
      <CardTitle>Flow Execution</CardTitle>
      <CardDescription>
        How flows are executed by the engine
      </CardDescription>
    </CardHeader>
    <div style={{ padding: '1rem', paddingTop: 0 }}>
      <a href="./flow-execution" style={{ textDecoration: 'none' }}>
        Learn execution →
      </a>
    </div>
  </Card>
</div>